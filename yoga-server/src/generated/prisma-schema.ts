// Code generated by Prisma (prisma@1.34.10). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

export const typeDefs = /* GraphQL */ `type Account {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime
  firstName: String!
  lastName: String!
  timezone: String!
  email: String!
  mobile_phone: String
  password_salt: String!
  password_hash: String!
  is_verified: Boolean!
  challenge: String
  profiles(where: ProfileWhereInput, orderBy: ProfileOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Profile!]
  sessions(where: SessionWhereInput, orderBy: SessionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Session!]
  lastUsedProfileId: String
}

type AccountConnection {
  pageInfo: PageInfo!
  edges: [AccountEdge]!
  aggregate: AggregateAccount!
}

input AccountCreateInput {
  id: ID
  firstName: String!
  lastName: String!
  timezone: String!
  email: String!
  mobile_phone: String
  password_salt: String!
  password_hash: String!
  is_verified: Boolean!
  challenge: String
  profiles: ProfileCreateManyWithoutCreatorInput
  sessions: SessionCreateManyWithoutAccountInput
  lastUsedProfileId: String
}

input AccountCreateOneWithoutProfilesInput {
  create: AccountCreateWithoutProfilesInput
  connect: AccountWhereUniqueInput
}

input AccountCreateOneWithoutSessionsInput {
  create: AccountCreateWithoutSessionsInput
  connect: AccountWhereUniqueInput
}

input AccountCreateWithoutProfilesInput {
  id: ID
  firstName: String!
  lastName: String!
  timezone: String!
  email: String!
  mobile_phone: String
  password_salt: String!
  password_hash: String!
  is_verified: Boolean!
  challenge: String
  sessions: SessionCreateManyWithoutAccountInput
  lastUsedProfileId: String
}

input AccountCreateWithoutSessionsInput {
  id: ID
  firstName: String!
  lastName: String!
  timezone: String!
  email: String!
  mobile_phone: String
  password_salt: String!
  password_hash: String!
  is_verified: Boolean!
  challenge: String
  profiles: ProfileCreateManyWithoutCreatorInput
  lastUsedProfileId: String
}

type AccountEdge {
  node: Account!
  cursor: String!
}

enum AccountOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  firstName_ASC
  firstName_DESC
  lastName_ASC
  lastName_DESC
  timezone_ASC
  timezone_DESC
  email_ASC
  email_DESC
  mobile_phone_ASC
  mobile_phone_DESC
  password_salt_ASC
  password_salt_DESC
  password_hash_ASC
  password_hash_DESC
  is_verified_ASC
  is_verified_DESC
  challenge_ASC
  challenge_DESC
  lastUsedProfileId_ASC
  lastUsedProfileId_DESC
}

type AccountPreviousValues {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime
  firstName: String!
  lastName: String!
  timezone: String!
  email: String!
  mobile_phone: String
  password_salt: String!
  password_hash: String!
  is_verified: Boolean!
  challenge: String
  lastUsedProfileId: String
}

type AccountSubscriptionPayload {
  mutation: MutationType!
  node: Account
  updatedFields: [String!]
  previousValues: AccountPreviousValues
}

input AccountSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: AccountWhereInput
  AND: [AccountSubscriptionWhereInput!]
  OR: [AccountSubscriptionWhereInput!]
  NOT: [AccountSubscriptionWhereInput!]
}

input AccountUpdateInput {
  firstName: String
  lastName: String
  timezone: String
  email: String
  mobile_phone: String
  password_salt: String
  password_hash: String
  is_verified: Boolean
  challenge: String
  profiles: ProfileUpdateManyWithoutCreatorInput
  sessions: SessionUpdateManyWithoutAccountInput
  lastUsedProfileId: String
}

input AccountUpdateManyMutationInput {
  firstName: String
  lastName: String
  timezone: String
  email: String
  mobile_phone: String
  password_salt: String
  password_hash: String
  is_verified: Boolean
  challenge: String
  lastUsedProfileId: String
}

input AccountUpdateOneRequiredWithoutProfilesInput {
  create: AccountCreateWithoutProfilesInput
  update: AccountUpdateWithoutProfilesDataInput
  upsert: AccountUpsertWithoutProfilesInput
  connect: AccountWhereUniqueInput
}

input AccountUpdateOneRequiredWithoutSessionsInput {
  create: AccountCreateWithoutSessionsInput
  update: AccountUpdateWithoutSessionsDataInput
  upsert: AccountUpsertWithoutSessionsInput
  connect: AccountWhereUniqueInput
}

input AccountUpdateWithoutProfilesDataInput {
  firstName: String
  lastName: String
  timezone: String
  email: String
  mobile_phone: String
  password_salt: String
  password_hash: String
  is_verified: Boolean
  challenge: String
  sessions: SessionUpdateManyWithoutAccountInput
  lastUsedProfileId: String
}

input AccountUpdateWithoutSessionsDataInput {
  firstName: String
  lastName: String
  timezone: String
  email: String
  mobile_phone: String
  password_salt: String
  password_hash: String
  is_verified: Boolean
  challenge: String
  profiles: ProfileUpdateManyWithoutCreatorInput
  lastUsedProfileId: String
}

input AccountUpsertWithoutProfilesInput {
  update: AccountUpdateWithoutProfilesDataInput!
  create: AccountCreateWithoutProfilesInput!
}

input AccountUpsertWithoutSessionsInput {
  update: AccountUpdateWithoutSessionsDataInput!
  create: AccountCreateWithoutSessionsInput!
}

input AccountWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  firstName: String
  firstName_not: String
  firstName_in: [String!]
  firstName_not_in: [String!]
  firstName_lt: String
  firstName_lte: String
  firstName_gt: String
  firstName_gte: String
  firstName_contains: String
  firstName_not_contains: String
  firstName_starts_with: String
  firstName_not_starts_with: String
  firstName_ends_with: String
  firstName_not_ends_with: String
  lastName: String
  lastName_not: String
  lastName_in: [String!]
  lastName_not_in: [String!]
  lastName_lt: String
  lastName_lte: String
  lastName_gt: String
  lastName_gte: String
  lastName_contains: String
  lastName_not_contains: String
  lastName_starts_with: String
  lastName_not_starts_with: String
  lastName_ends_with: String
  lastName_not_ends_with: String
  timezone: String
  timezone_not: String
  timezone_in: [String!]
  timezone_not_in: [String!]
  timezone_lt: String
  timezone_lte: String
  timezone_gt: String
  timezone_gte: String
  timezone_contains: String
  timezone_not_contains: String
  timezone_starts_with: String
  timezone_not_starts_with: String
  timezone_ends_with: String
  timezone_not_ends_with: String
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  mobile_phone: String
  mobile_phone_not: String
  mobile_phone_in: [String!]
  mobile_phone_not_in: [String!]
  mobile_phone_lt: String
  mobile_phone_lte: String
  mobile_phone_gt: String
  mobile_phone_gte: String
  mobile_phone_contains: String
  mobile_phone_not_contains: String
  mobile_phone_starts_with: String
  mobile_phone_not_starts_with: String
  mobile_phone_ends_with: String
  mobile_phone_not_ends_with: String
  password_salt: String
  password_salt_not: String
  password_salt_in: [String!]
  password_salt_not_in: [String!]
  password_salt_lt: String
  password_salt_lte: String
  password_salt_gt: String
  password_salt_gte: String
  password_salt_contains: String
  password_salt_not_contains: String
  password_salt_starts_with: String
  password_salt_not_starts_with: String
  password_salt_ends_with: String
  password_salt_not_ends_with: String
  password_hash: String
  password_hash_not: String
  password_hash_in: [String!]
  password_hash_not_in: [String!]
  password_hash_lt: String
  password_hash_lte: String
  password_hash_gt: String
  password_hash_gte: String
  password_hash_contains: String
  password_hash_not_contains: String
  password_hash_starts_with: String
  password_hash_not_starts_with: String
  password_hash_ends_with: String
  password_hash_not_ends_with: String
  is_verified: Boolean
  is_verified_not: Boolean
  challenge: String
  challenge_not: String
  challenge_in: [String!]
  challenge_not_in: [String!]
  challenge_lt: String
  challenge_lte: String
  challenge_gt: String
  challenge_gte: String
  challenge_contains: String
  challenge_not_contains: String
  challenge_starts_with: String
  challenge_not_starts_with: String
  challenge_ends_with: String
  challenge_not_ends_with: String
  profiles_every: ProfileWhereInput
  profiles_some: ProfileWhereInput
  profiles_none: ProfileWhereInput
  sessions_every: SessionWhereInput
  sessions_some: SessionWhereInput
  sessions_none: SessionWhereInput
  lastUsedProfileId: String
  lastUsedProfileId_not: String
  lastUsedProfileId_in: [String!]
  lastUsedProfileId_not_in: [String!]
  lastUsedProfileId_lt: String
  lastUsedProfileId_lte: String
  lastUsedProfileId_gt: String
  lastUsedProfileId_gte: String
  lastUsedProfileId_contains: String
  lastUsedProfileId_not_contains: String
  lastUsedProfileId_starts_with: String
  lastUsedProfileId_not_starts_with: String
  lastUsedProfileId_ends_with: String
  lastUsedProfileId_not_ends_with: String
  AND: [AccountWhereInput!]
  OR: [AccountWhereInput!]
  NOT: [AccountWhereInput!]
}

input AccountWhereUniqueInput {
  id: ID
  email: String
}

type AggregateAccount {
  count: Int!
}

type AggregateAttachment {
  count: Int!
}

type AggregateGroup {
  count: Int!
}

type AggregateLocation {
  count: Int!
}

type AggregateMembership {
  count: Int!
}

type AggregateMessage {
  count: Int!
}

type AggregateProfile {
  count: Int!
}

type AggregateReaction {
  count: Int!
}

type AggregateSession {
  count: Int!
}

type AggregateTag {
  count: Int!
}

type Attachment {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime
  creator: Profile!
  name: String!
  type: AttachmentType!
  link: String
  tags(where: TagWhereInput, orderBy: TagOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Tag!]
}

type AttachmentConnection {
  pageInfo: PageInfo!
  edges: [AttachmentEdge]!
  aggregate: AggregateAttachment!
}

input AttachmentCreateInput {
  id: ID
  creator: ProfileCreateOneInput!
  name: String!
  type: AttachmentType!
  link: String
  tags: TagCreateManyInput
}

input AttachmentCreateManyInput {
  create: [AttachmentCreateInput!]
  connect: [AttachmentWhereUniqueInput!]
}

type AttachmentEdge {
  node: Attachment!
  cursor: String!
}

enum AttachmentOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  name_ASC
  name_DESC
  type_ASC
  type_DESC
  link_ASC
  link_DESC
}

type AttachmentPreviousValues {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime
  name: String!
  type: AttachmentType!
  link: String
}

input AttachmentScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  type: AttachmentType
  type_not: AttachmentType
  type_in: [AttachmentType!]
  type_not_in: [AttachmentType!]
  link: String
  link_not: String
  link_in: [String!]
  link_not_in: [String!]
  link_lt: String
  link_lte: String
  link_gt: String
  link_gte: String
  link_contains: String
  link_not_contains: String
  link_starts_with: String
  link_not_starts_with: String
  link_ends_with: String
  link_not_ends_with: String
  AND: [AttachmentScalarWhereInput!]
  OR: [AttachmentScalarWhereInput!]
  NOT: [AttachmentScalarWhereInput!]
}

type AttachmentSubscriptionPayload {
  mutation: MutationType!
  node: Attachment
  updatedFields: [String!]
  previousValues: AttachmentPreviousValues
}

input AttachmentSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: AttachmentWhereInput
  AND: [AttachmentSubscriptionWhereInput!]
  OR: [AttachmentSubscriptionWhereInput!]
  NOT: [AttachmentSubscriptionWhereInput!]
}

enum AttachmentType {
  DOCUMENT
  PICTURE
  LINK
  VIDEO
  AUDIO
}

input AttachmentUpdateDataInput {
  creator: ProfileUpdateOneRequiredInput
  name: String
  type: AttachmentType
  link: String
  tags: TagUpdateManyInput
}

input AttachmentUpdateInput {
  creator: ProfileUpdateOneRequiredInput
  name: String
  type: AttachmentType
  link: String
  tags: TagUpdateManyInput
}

input AttachmentUpdateManyDataInput {
  name: String
  type: AttachmentType
  link: String
}

input AttachmentUpdateManyInput {
  create: [AttachmentCreateInput!]
  update: [AttachmentUpdateWithWhereUniqueNestedInput!]
  upsert: [AttachmentUpsertWithWhereUniqueNestedInput!]
  delete: [AttachmentWhereUniqueInput!]
  connect: [AttachmentWhereUniqueInput!]
  set: [AttachmentWhereUniqueInput!]
  disconnect: [AttachmentWhereUniqueInput!]
  deleteMany: [AttachmentScalarWhereInput!]
  updateMany: [AttachmentUpdateManyWithWhereNestedInput!]
}

input AttachmentUpdateManyMutationInput {
  name: String
  type: AttachmentType
  link: String
}

input AttachmentUpdateManyWithWhereNestedInput {
  where: AttachmentScalarWhereInput!
  data: AttachmentUpdateManyDataInput!
}

input AttachmentUpdateWithWhereUniqueNestedInput {
  where: AttachmentWhereUniqueInput!
  data: AttachmentUpdateDataInput!
}

input AttachmentUpsertWithWhereUniqueNestedInput {
  where: AttachmentWhereUniqueInput!
  update: AttachmentUpdateDataInput!
  create: AttachmentCreateInput!
}

input AttachmentWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  creator: ProfileWhereInput
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  type: AttachmentType
  type_not: AttachmentType
  type_in: [AttachmentType!]
  type_not_in: [AttachmentType!]
  link: String
  link_not: String
  link_in: [String!]
  link_not_in: [String!]
  link_lt: String
  link_lte: String
  link_gt: String
  link_gte: String
  link_contains: String
  link_not_contains: String
  link_starts_with: String
  link_not_starts_with: String
  link_ends_with: String
  link_not_ends_with: String
  tags_every: TagWhereInput
  tags_some: TagWhereInput
  tags_none: TagWhereInput
  AND: [AttachmentWhereInput!]
  OR: [AttachmentWhereInput!]
  NOT: [AttachmentWhereInput!]
}

input AttachmentWhereUniqueInput {
  id: ID
}

type BatchPayload {
  count: Long!
}

scalar DateTime

type Group {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime
  creator: Profile!
  name: String!
  title: String!
  description: String!
  logo: String!
  type: GroupType!
  parent: Group
  is_hidden: Boolean!
  is_public: Boolean!
  members(where: MembershipWhereInput, orderBy: MembershipOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Membership!]
  messages(where: MessageWhereInput, orderBy: MessageOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Message!]
  tags(where: TagWhereInput, orderBy: TagOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Tag!]
  location: Location
  members_count: Int
  members_online: Int
  messages_count: Int
}

type GroupConnection {
  pageInfo: PageInfo!
  edges: [GroupEdge]!
  aggregate: AggregateGroup!
}

input GroupCreateInput {
  id: ID
  creator: ProfileCreateOneInput!
  name: String!
  title: String!
  description: String!
  logo: String!
  type: GroupType!
  parent: GroupCreateOneInput
  is_hidden: Boolean!
  is_public: Boolean!
  members: MembershipCreateManyWithoutGroupInput
  messages: MessageCreateManyInput
  tags: TagCreateManyInput
  location: LocationCreateOneInput
  members_count: Int
  members_online: Int
  messages_count: Int
}

input GroupCreateOneInput {
  create: GroupCreateInput
  connect: GroupWhereUniqueInput
}

input GroupCreateOneWithoutMembersInput {
  create: GroupCreateWithoutMembersInput
  connect: GroupWhereUniqueInput
}

input GroupCreateWithoutMembersInput {
  id: ID
  creator: ProfileCreateOneInput!
  name: String!
  title: String!
  description: String!
  logo: String!
  type: GroupType!
  parent: GroupCreateOneInput
  is_hidden: Boolean!
  is_public: Boolean!
  messages: MessageCreateManyInput
  tags: TagCreateManyInput
  location: LocationCreateOneInput
  members_count: Int
  members_online: Int
  messages_count: Int
}

type GroupEdge {
  node: Group!
  cursor: String!
}

enum GroupOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  name_ASC
  name_DESC
  title_ASC
  title_DESC
  description_ASC
  description_DESC
  logo_ASC
  logo_DESC
  type_ASC
  type_DESC
  is_hidden_ASC
  is_hidden_DESC
  is_public_ASC
  is_public_DESC
  members_count_ASC
  members_count_DESC
  members_online_ASC
  members_online_DESC
  messages_count_ASC
  messages_count_DESC
}

type GroupPreviousValues {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime
  name: String!
  title: String!
  description: String!
  logo: String!
  type: GroupType!
  is_hidden: Boolean!
  is_public: Boolean!
  members_count: Int
  members_online: Int
  messages_count: Int
}

type GroupSubscriptionPayload {
  mutation: MutationType!
  node: Group
  updatedFields: [String!]
  previousValues: GroupPreviousValues
}

input GroupSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: GroupWhereInput
  AND: [GroupSubscriptionWhereInput!]
  OR: [GroupSubscriptionWhereInput!]
  NOT: [GroupSubscriptionWhereInput!]
}

enum GroupType {
  ROOM
  CHANNEL
  THREAD
  FRIENDS
}

input GroupUpdateDataInput {
  creator: ProfileUpdateOneRequiredInput
  name: String
  title: String
  description: String
  logo: String
  type: GroupType
  parent: GroupUpdateOneInput
  is_hidden: Boolean
  is_public: Boolean
  members: MembershipUpdateManyWithoutGroupInput
  messages: MessageUpdateManyInput
  tags: TagUpdateManyInput
  location: LocationUpdateOneInput
  members_count: Int
  members_online: Int
  messages_count: Int
}

input GroupUpdateInput {
  creator: ProfileUpdateOneRequiredInput
  name: String
  title: String
  description: String
  logo: String
  type: GroupType
  parent: GroupUpdateOneInput
  is_hidden: Boolean
  is_public: Boolean
  members: MembershipUpdateManyWithoutGroupInput
  messages: MessageUpdateManyInput
  tags: TagUpdateManyInput
  location: LocationUpdateOneInput
  members_count: Int
  members_online: Int
  messages_count: Int
}

input GroupUpdateManyMutationInput {
  name: String
  title: String
  description: String
  logo: String
  type: GroupType
  is_hidden: Boolean
  is_public: Boolean
  members_count: Int
  members_online: Int
  messages_count: Int
}

input GroupUpdateOneInput {
  create: GroupCreateInput
  update: GroupUpdateDataInput
  upsert: GroupUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: GroupWhereUniqueInput
}

input GroupUpdateOneRequiredWithoutMembersInput {
  create: GroupCreateWithoutMembersInput
  update: GroupUpdateWithoutMembersDataInput
  upsert: GroupUpsertWithoutMembersInput
  connect: GroupWhereUniqueInput
}

input GroupUpdateWithoutMembersDataInput {
  creator: ProfileUpdateOneRequiredInput
  name: String
  title: String
  description: String
  logo: String
  type: GroupType
  parent: GroupUpdateOneInput
  is_hidden: Boolean
  is_public: Boolean
  messages: MessageUpdateManyInput
  tags: TagUpdateManyInput
  location: LocationUpdateOneInput
  members_count: Int
  members_online: Int
  messages_count: Int
}

input GroupUpsertNestedInput {
  update: GroupUpdateDataInput!
  create: GroupCreateInput!
}

input GroupUpsertWithoutMembersInput {
  update: GroupUpdateWithoutMembersDataInput!
  create: GroupCreateWithoutMembersInput!
}

input GroupWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  creator: ProfileWhereInput
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  logo: String
  logo_not: String
  logo_in: [String!]
  logo_not_in: [String!]
  logo_lt: String
  logo_lte: String
  logo_gt: String
  logo_gte: String
  logo_contains: String
  logo_not_contains: String
  logo_starts_with: String
  logo_not_starts_with: String
  logo_ends_with: String
  logo_not_ends_with: String
  type: GroupType
  type_not: GroupType
  type_in: [GroupType!]
  type_not_in: [GroupType!]
  parent: GroupWhereInput
  is_hidden: Boolean
  is_hidden_not: Boolean
  is_public: Boolean
  is_public_not: Boolean
  members_every: MembershipWhereInput
  members_some: MembershipWhereInput
  members_none: MembershipWhereInput
  messages_every: MessageWhereInput
  messages_some: MessageWhereInput
  messages_none: MessageWhereInput
  tags_every: TagWhereInput
  tags_some: TagWhereInput
  tags_none: TagWhereInput
  location: LocationWhereInput
  members_count: Int
  members_count_not: Int
  members_count_in: [Int!]
  members_count_not_in: [Int!]
  members_count_lt: Int
  members_count_lte: Int
  members_count_gt: Int
  members_count_gte: Int
  members_online: Int
  members_online_not: Int
  members_online_in: [Int!]
  members_online_not_in: [Int!]
  members_online_lt: Int
  members_online_lte: Int
  members_online_gt: Int
  members_online_gte: Int
  messages_count: Int
  messages_count_not: Int
  messages_count_in: [Int!]
  messages_count_not_in: [Int!]
  messages_count_lt: Int
  messages_count_lte: Int
  messages_count_gt: Int
  messages_count_gte: Int
  AND: [GroupWhereInput!]
  OR: [GroupWhereInput!]
  NOT: [GroupWhereInput!]
}

input GroupWhereUniqueInput {
  id: ID
}

scalar Json

type Location {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  creator: Profile!
  type: LocationType!
  name: String
  address: String
  zip_code: String
  city: String
  country: String
  continent: String
  latitude: Float!
  longitude: Float!
  radius_meter: Float
  tags(where: TagWhereInput, orderBy: TagOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Tag!]
  visitors_count: Int
}

type LocationConnection {
  pageInfo: PageInfo!
  edges: [LocationEdge]!
  aggregate: AggregateLocation!
}

input LocationCreateInput {
  id: ID
  creator: ProfileCreateOneInput!
  type: LocationType!
  name: String
  address: String
  zip_code: String
  city: String
  country: String
  continent: String
  latitude: Float!
  longitude: Float!
  radius_meter: Float
  tags: TagCreateManyInput
  visitors_count: Int
}

input LocationCreateOneInput {
  create: LocationCreateInput
  connect: LocationWhereUniqueInput
}

type LocationEdge {
  node: Location!
  cursor: String!
}

enum LocationOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  type_ASC
  type_DESC
  name_ASC
  name_DESC
  address_ASC
  address_DESC
  zip_code_ASC
  zip_code_DESC
  city_ASC
  city_DESC
  country_ASC
  country_DESC
  continent_ASC
  continent_DESC
  latitude_ASC
  latitude_DESC
  longitude_ASC
  longitude_DESC
  radius_meter_ASC
  radius_meter_DESC
  visitors_count_ASC
  visitors_count_DESC
}

type LocationPreviousValues {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  type: LocationType!
  name: String
  address: String
  zip_code: String
  city: String
  country: String
  continent: String
  latitude: Float!
  longitude: Float!
  radius_meter: Float
  visitors_count: Int
}

type LocationSubscriptionPayload {
  mutation: MutationType!
  node: Location
  updatedFields: [String!]
  previousValues: LocationPreviousValues
}

input LocationSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: LocationWhereInput
  AND: [LocationSubscriptionWhereInput!]
  OR: [LocationSubscriptionWhereInput!]
  NOT: [LocationSubscriptionWhereInput!]
}

enum LocationType {
  GEOGRAPHIC
  POI
}

input LocationUpdateDataInput {
  creator: ProfileUpdateOneRequiredInput
  type: LocationType
  name: String
  address: String
  zip_code: String
  city: String
  country: String
  continent: String
  latitude: Float
  longitude: Float
  radius_meter: Float
  tags: TagUpdateManyInput
  visitors_count: Int
}

input LocationUpdateInput {
  creator: ProfileUpdateOneRequiredInput
  type: LocationType
  name: String
  address: String
  zip_code: String
  city: String
  country: String
  continent: String
  latitude: Float
  longitude: Float
  radius_meter: Float
  tags: TagUpdateManyInput
  visitors_count: Int
}

input LocationUpdateManyMutationInput {
  type: LocationType
  name: String
  address: String
  zip_code: String
  city: String
  country: String
  continent: String
  latitude: Float
  longitude: Float
  radius_meter: Float
  visitors_count: Int
}

input LocationUpdateOneInput {
  create: LocationCreateInput
  update: LocationUpdateDataInput
  upsert: LocationUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: LocationWhereUniqueInput
}

input LocationUpsertNestedInput {
  update: LocationUpdateDataInput!
  create: LocationCreateInput!
}

input LocationWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  creator: ProfileWhereInput
  type: LocationType
  type_not: LocationType
  type_in: [LocationType!]
  type_not_in: [LocationType!]
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  address: String
  address_not: String
  address_in: [String!]
  address_not_in: [String!]
  address_lt: String
  address_lte: String
  address_gt: String
  address_gte: String
  address_contains: String
  address_not_contains: String
  address_starts_with: String
  address_not_starts_with: String
  address_ends_with: String
  address_not_ends_with: String
  zip_code: String
  zip_code_not: String
  zip_code_in: [String!]
  zip_code_not_in: [String!]
  zip_code_lt: String
  zip_code_lte: String
  zip_code_gt: String
  zip_code_gte: String
  zip_code_contains: String
  zip_code_not_contains: String
  zip_code_starts_with: String
  zip_code_not_starts_with: String
  zip_code_ends_with: String
  zip_code_not_ends_with: String
  city: String
  city_not: String
  city_in: [String!]
  city_not_in: [String!]
  city_lt: String
  city_lte: String
  city_gt: String
  city_gte: String
  city_contains: String
  city_not_contains: String
  city_starts_with: String
  city_not_starts_with: String
  city_ends_with: String
  city_not_ends_with: String
  country: String
  country_not: String
  country_in: [String!]
  country_not_in: [String!]
  country_lt: String
  country_lte: String
  country_gt: String
  country_gte: String
  country_contains: String
  country_not_contains: String
  country_starts_with: String
  country_not_starts_with: String
  country_ends_with: String
  country_not_ends_with: String
  continent: String
  continent_not: String
  continent_in: [String!]
  continent_not_in: [String!]
  continent_lt: String
  continent_lte: String
  continent_gt: String
  continent_gte: String
  continent_contains: String
  continent_not_contains: String
  continent_starts_with: String
  continent_not_starts_with: String
  continent_ends_with: String
  continent_not_ends_with: String
  latitude: Float
  latitude_not: Float
  latitude_in: [Float!]
  latitude_not_in: [Float!]
  latitude_lt: Float
  latitude_lte: Float
  latitude_gt: Float
  latitude_gte: Float
  longitude: Float
  longitude_not: Float
  longitude_in: [Float!]
  longitude_not_in: [Float!]
  longitude_lt: Float
  longitude_lte: Float
  longitude_gt: Float
  longitude_gte: Float
  radius_meter: Float
  radius_meter_not: Float
  radius_meter_in: [Float!]
  radius_meter_not_in: [Float!]
  radius_meter_lt: Float
  radius_meter_lte: Float
  radius_meter_gt: Float
  radius_meter_gte: Float
  tags_every: TagWhereInput
  tags_some: TagWhereInput
  tags_none: TagWhereInput
  visitors_count: Int
  visitors_count_not: Int
  visitors_count_in: [Int!]
  visitors_count_not_in: [Int!]
  visitors_count_lt: Int
  visitors_count_lte: Int
  visitors_count_gt: Int
  visitors_count_gte: Int
  AND: [LocationWhereInput!]
  OR: [LocationWhereInput!]
  NOT: [LocationWhereInput!]
}

input LocationWhereUniqueInput {
  id: ID
}

scalar Long

type Membership {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime
  creator: Profile!
  can_read: Boolean!
  can_write: Boolean!
  can_delete: Boolean!
  member: Profile!
  group: Group!
  show_history: Boolean!
}

type MembershipConnection {
  pageInfo: PageInfo!
  edges: [MembershipEdge]!
  aggregate: AggregateMembership!
}

input MembershipCreateInput {
  id: ID
  creator: ProfileCreateOneWithoutInviteesInput!
  can_read: Boolean!
  can_write: Boolean!
  can_delete: Boolean!
  member: ProfileCreateOneWithoutMembershipsInput!
  group: GroupCreateOneWithoutMembersInput!
  show_history: Boolean!
}

input MembershipCreateManyWithoutCreatorInput {
  create: [MembershipCreateWithoutCreatorInput!]
  connect: [MembershipWhereUniqueInput!]
}

input MembershipCreateManyWithoutGroupInput {
  create: [MembershipCreateWithoutGroupInput!]
  connect: [MembershipWhereUniqueInput!]
}

input MembershipCreateManyWithoutMemberInput {
  create: [MembershipCreateWithoutMemberInput!]
  connect: [MembershipWhereUniqueInput!]
}

input MembershipCreateWithoutCreatorInput {
  id: ID
  can_read: Boolean!
  can_write: Boolean!
  can_delete: Boolean!
  member: ProfileCreateOneWithoutMembershipsInput!
  group: GroupCreateOneWithoutMembersInput!
  show_history: Boolean!
}

input MembershipCreateWithoutGroupInput {
  id: ID
  creator: ProfileCreateOneWithoutInviteesInput!
  can_read: Boolean!
  can_write: Boolean!
  can_delete: Boolean!
  member: ProfileCreateOneWithoutMembershipsInput!
  show_history: Boolean!
}

input MembershipCreateWithoutMemberInput {
  id: ID
  creator: ProfileCreateOneWithoutInviteesInput!
  can_read: Boolean!
  can_write: Boolean!
  can_delete: Boolean!
  group: GroupCreateOneWithoutMembersInput!
  show_history: Boolean!
}

type MembershipEdge {
  node: Membership!
  cursor: String!
}

enum MembershipOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  can_read_ASC
  can_read_DESC
  can_write_ASC
  can_write_DESC
  can_delete_ASC
  can_delete_DESC
  show_history_ASC
  show_history_DESC
}

type MembershipPreviousValues {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime
  can_read: Boolean!
  can_write: Boolean!
  can_delete: Boolean!
  show_history: Boolean!
}

input MembershipScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  can_read: Boolean
  can_read_not: Boolean
  can_write: Boolean
  can_write_not: Boolean
  can_delete: Boolean
  can_delete_not: Boolean
  show_history: Boolean
  show_history_not: Boolean
  AND: [MembershipScalarWhereInput!]
  OR: [MembershipScalarWhereInput!]
  NOT: [MembershipScalarWhereInput!]
}

type MembershipSubscriptionPayload {
  mutation: MutationType!
  node: Membership
  updatedFields: [String!]
  previousValues: MembershipPreviousValues
}

input MembershipSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: MembershipWhereInput
  AND: [MembershipSubscriptionWhereInput!]
  OR: [MembershipSubscriptionWhereInput!]
  NOT: [MembershipSubscriptionWhereInput!]
}

input MembershipUpdateInput {
  creator: ProfileUpdateOneRequiredWithoutInviteesInput
  can_read: Boolean
  can_write: Boolean
  can_delete: Boolean
  member: ProfileUpdateOneRequiredWithoutMembershipsInput
  group: GroupUpdateOneRequiredWithoutMembersInput
  show_history: Boolean
}

input MembershipUpdateManyDataInput {
  can_read: Boolean
  can_write: Boolean
  can_delete: Boolean
  show_history: Boolean
}

input MembershipUpdateManyMutationInput {
  can_read: Boolean
  can_write: Boolean
  can_delete: Boolean
  show_history: Boolean
}

input MembershipUpdateManyWithoutCreatorInput {
  create: [MembershipCreateWithoutCreatorInput!]
  delete: [MembershipWhereUniqueInput!]
  connect: [MembershipWhereUniqueInput!]
  set: [MembershipWhereUniqueInput!]
  disconnect: [MembershipWhereUniqueInput!]
  update: [MembershipUpdateWithWhereUniqueWithoutCreatorInput!]
  upsert: [MembershipUpsertWithWhereUniqueWithoutCreatorInput!]
  deleteMany: [MembershipScalarWhereInput!]
  updateMany: [MembershipUpdateManyWithWhereNestedInput!]
}

input MembershipUpdateManyWithoutGroupInput {
  create: [MembershipCreateWithoutGroupInput!]
  delete: [MembershipWhereUniqueInput!]
  connect: [MembershipWhereUniqueInput!]
  set: [MembershipWhereUniqueInput!]
  disconnect: [MembershipWhereUniqueInput!]
  update: [MembershipUpdateWithWhereUniqueWithoutGroupInput!]
  upsert: [MembershipUpsertWithWhereUniqueWithoutGroupInput!]
  deleteMany: [MembershipScalarWhereInput!]
  updateMany: [MembershipUpdateManyWithWhereNestedInput!]
}

input MembershipUpdateManyWithoutMemberInput {
  create: [MembershipCreateWithoutMemberInput!]
  delete: [MembershipWhereUniqueInput!]
  connect: [MembershipWhereUniqueInput!]
  set: [MembershipWhereUniqueInput!]
  disconnect: [MembershipWhereUniqueInput!]
  update: [MembershipUpdateWithWhereUniqueWithoutMemberInput!]
  upsert: [MembershipUpsertWithWhereUniqueWithoutMemberInput!]
  deleteMany: [MembershipScalarWhereInput!]
  updateMany: [MembershipUpdateManyWithWhereNestedInput!]
}

input MembershipUpdateManyWithWhereNestedInput {
  where: MembershipScalarWhereInput!
  data: MembershipUpdateManyDataInput!
}

input MembershipUpdateWithoutCreatorDataInput {
  can_read: Boolean
  can_write: Boolean
  can_delete: Boolean
  member: ProfileUpdateOneRequiredWithoutMembershipsInput
  group: GroupUpdateOneRequiredWithoutMembersInput
  show_history: Boolean
}

input MembershipUpdateWithoutGroupDataInput {
  creator: ProfileUpdateOneRequiredWithoutInviteesInput
  can_read: Boolean
  can_write: Boolean
  can_delete: Boolean
  member: ProfileUpdateOneRequiredWithoutMembershipsInput
  show_history: Boolean
}

input MembershipUpdateWithoutMemberDataInput {
  creator: ProfileUpdateOneRequiredWithoutInviteesInput
  can_read: Boolean
  can_write: Boolean
  can_delete: Boolean
  group: GroupUpdateOneRequiredWithoutMembersInput
  show_history: Boolean
}

input MembershipUpdateWithWhereUniqueWithoutCreatorInput {
  where: MembershipWhereUniqueInput!
  data: MembershipUpdateWithoutCreatorDataInput!
}

input MembershipUpdateWithWhereUniqueWithoutGroupInput {
  where: MembershipWhereUniqueInput!
  data: MembershipUpdateWithoutGroupDataInput!
}

input MembershipUpdateWithWhereUniqueWithoutMemberInput {
  where: MembershipWhereUniqueInput!
  data: MembershipUpdateWithoutMemberDataInput!
}

input MembershipUpsertWithWhereUniqueWithoutCreatorInput {
  where: MembershipWhereUniqueInput!
  update: MembershipUpdateWithoutCreatorDataInput!
  create: MembershipCreateWithoutCreatorInput!
}

input MembershipUpsertWithWhereUniqueWithoutGroupInput {
  where: MembershipWhereUniqueInput!
  update: MembershipUpdateWithoutGroupDataInput!
  create: MembershipCreateWithoutGroupInput!
}

input MembershipUpsertWithWhereUniqueWithoutMemberInput {
  where: MembershipWhereUniqueInput!
  update: MembershipUpdateWithoutMemberDataInput!
  create: MembershipCreateWithoutMemberInput!
}

input MembershipWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  creator: ProfileWhereInput
  can_read: Boolean
  can_read_not: Boolean
  can_write: Boolean
  can_write_not: Boolean
  can_delete: Boolean
  can_delete_not: Boolean
  member: ProfileWhereInput
  group: GroupWhereInput
  show_history: Boolean
  show_history_not: Boolean
  AND: [MembershipWhereInput!]
  OR: [MembershipWhereInput!]
  NOT: [MembershipWhereInput!]
}

input MembershipWhereUniqueInput {
  id: ID
}

type Message {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime
  creator: Profile!
  type: MessageType!
  parent: Message
  subject: String
  content: Json
  attachments(where: AttachmentWhereInput, orderBy: AttachmentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Attachment!]
  reactions(where: ReactionWhereInput, orderBy: ReactionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Reaction!]
  tags(where: TagWhereInput, orderBy: TagOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Tag!]
}

type MessageConnection {
  pageInfo: PageInfo!
  edges: [MessageEdge]!
  aggregate: AggregateMessage!
}

input MessageCreateInput {
  id: ID
  creator: ProfileCreateOneInput!
  type: MessageType!
  parent: MessageCreateOneInput
  subject: String
  content: Json
  attachments: AttachmentCreateManyInput
  reactions: ReactionCreateManyInput
  tags: TagCreateManyInput
}

input MessageCreateManyInput {
  create: [MessageCreateInput!]
  connect: [MessageWhereUniqueInput!]
}

input MessageCreateOneInput {
  create: MessageCreateInput
  connect: MessageWhereUniqueInput
}

type MessageEdge {
  node: Message!
  cursor: String!
}

enum MessageOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  type_ASC
  type_DESC
  subject_ASC
  subject_DESC
  content_ASC
  content_DESC
}

type MessagePreviousValues {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime
  type: MessageType!
  subject: String
  content: Json
}

input MessageScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  type: MessageType
  type_not: MessageType
  type_in: [MessageType!]
  type_not_in: [MessageType!]
  subject: String
  subject_not: String
  subject_in: [String!]
  subject_not_in: [String!]
  subject_lt: String
  subject_lte: String
  subject_gt: String
  subject_gte: String
  subject_contains: String
  subject_not_contains: String
  subject_starts_with: String
  subject_not_starts_with: String
  subject_ends_with: String
  subject_not_ends_with: String
  AND: [MessageScalarWhereInput!]
  OR: [MessageScalarWhereInput!]
  NOT: [MessageScalarWhereInput!]
}

type MessageSubscriptionPayload {
  mutation: MutationType!
  node: Message
  updatedFields: [String!]
  previousValues: MessagePreviousValues
}

input MessageSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: MessageWhereInput
  AND: [MessageSubscriptionWhereInput!]
  OR: [MessageSubscriptionWhereInput!]
  NOT: [MessageSubscriptionWhereInput!]
}

enum MessageType {
  NOTIFICATION
  DIRECT_MESSAGE
  COMMENT
  POST
}

input MessageUpdateDataInput {
  creator: ProfileUpdateOneRequiredInput
  type: MessageType
  parent: MessageUpdateOneInput
  subject: String
  content: Json
  attachments: AttachmentUpdateManyInput
  reactions: ReactionUpdateManyInput
  tags: TagUpdateManyInput
}

input MessageUpdateInput {
  creator: ProfileUpdateOneRequiredInput
  type: MessageType
  parent: MessageUpdateOneInput
  subject: String
  content: Json
  attachments: AttachmentUpdateManyInput
  reactions: ReactionUpdateManyInput
  tags: TagUpdateManyInput
}

input MessageUpdateManyDataInput {
  type: MessageType
  subject: String
  content: Json
}

input MessageUpdateManyInput {
  create: [MessageCreateInput!]
  update: [MessageUpdateWithWhereUniqueNestedInput!]
  upsert: [MessageUpsertWithWhereUniqueNestedInput!]
  delete: [MessageWhereUniqueInput!]
  connect: [MessageWhereUniqueInput!]
  set: [MessageWhereUniqueInput!]
  disconnect: [MessageWhereUniqueInput!]
  deleteMany: [MessageScalarWhereInput!]
  updateMany: [MessageUpdateManyWithWhereNestedInput!]
}

input MessageUpdateManyMutationInput {
  type: MessageType
  subject: String
  content: Json
}

input MessageUpdateManyWithWhereNestedInput {
  where: MessageScalarWhereInput!
  data: MessageUpdateManyDataInput!
}

input MessageUpdateOneInput {
  create: MessageCreateInput
  update: MessageUpdateDataInput
  upsert: MessageUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: MessageWhereUniqueInput
}

input MessageUpdateWithWhereUniqueNestedInput {
  where: MessageWhereUniqueInput!
  data: MessageUpdateDataInput!
}

input MessageUpsertNestedInput {
  update: MessageUpdateDataInput!
  create: MessageCreateInput!
}

input MessageUpsertWithWhereUniqueNestedInput {
  where: MessageWhereUniqueInput!
  update: MessageUpdateDataInput!
  create: MessageCreateInput!
}

input MessageWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  creator: ProfileWhereInput
  type: MessageType
  type_not: MessageType
  type_in: [MessageType!]
  type_not_in: [MessageType!]
  parent: MessageWhereInput
  subject: String
  subject_not: String
  subject_in: [String!]
  subject_not_in: [String!]
  subject_lt: String
  subject_lte: String
  subject_gt: String
  subject_gte: String
  subject_contains: String
  subject_not_contains: String
  subject_starts_with: String
  subject_not_starts_with: String
  subject_ends_with: String
  subject_not_ends_with: String
  attachments_every: AttachmentWhereInput
  attachments_some: AttachmentWhereInput
  attachments_none: AttachmentWhereInput
  reactions_every: ReactionWhereInput
  reactions_some: ReactionWhereInput
  reactions_none: ReactionWhereInput
  tags_every: TagWhereInput
  tags_some: TagWhereInput
  tags_none: TagWhereInput
  AND: [MessageWhereInput!]
  OR: [MessageWhereInput!]
  NOT: [MessageWhereInput!]
}

input MessageWhereUniqueInput {
  id: ID
}

type Mutation {
  createAccount(data: AccountCreateInput!): Account!
  updateAccount(data: AccountUpdateInput!, where: AccountWhereUniqueInput!): Account
  updateManyAccounts(data: AccountUpdateManyMutationInput!, where: AccountWhereInput): BatchPayload!
  upsertAccount(where: AccountWhereUniqueInput!, create: AccountCreateInput!, update: AccountUpdateInput!): Account!
  deleteAccount(where: AccountWhereUniqueInput!): Account
  deleteManyAccounts(where: AccountWhereInput): BatchPayload!
  createAttachment(data: AttachmentCreateInput!): Attachment!
  updateAttachment(data: AttachmentUpdateInput!, where: AttachmentWhereUniqueInput!): Attachment
  updateManyAttachments(data: AttachmentUpdateManyMutationInput!, where: AttachmentWhereInput): BatchPayload!
  upsertAttachment(where: AttachmentWhereUniqueInput!, create: AttachmentCreateInput!, update: AttachmentUpdateInput!): Attachment!
  deleteAttachment(where: AttachmentWhereUniqueInput!): Attachment
  deleteManyAttachments(where: AttachmentWhereInput): BatchPayload!
  createGroup(data: GroupCreateInput!): Group!
  updateGroup(data: GroupUpdateInput!, where: GroupWhereUniqueInput!): Group
  updateManyGroups(data: GroupUpdateManyMutationInput!, where: GroupWhereInput): BatchPayload!
  upsertGroup(where: GroupWhereUniqueInput!, create: GroupCreateInput!, update: GroupUpdateInput!): Group!
  deleteGroup(where: GroupWhereUniqueInput!): Group
  deleteManyGroups(where: GroupWhereInput): BatchPayload!
  createLocation(data: LocationCreateInput!): Location!
  updateLocation(data: LocationUpdateInput!, where: LocationWhereUniqueInput!): Location
  updateManyLocations(data: LocationUpdateManyMutationInput!, where: LocationWhereInput): BatchPayload!
  upsertLocation(where: LocationWhereUniqueInput!, create: LocationCreateInput!, update: LocationUpdateInput!): Location!
  deleteLocation(where: LocationWhereUniqueInput!): Location
  deleteManyLocations(where: LocationWhereInput): BatchPayload!
  createMembership(data: MembershipCreateInput!): Membership!
  updateMembership(data: MembershipUpdateInput!, where: MembershipWhereUniqueInput!): Membership
  updateManyMemberships(data: MembershipUpdateManyMutationInput!, where: MembershipWhereInput): BatchPayload!
  upsertMembership(where: MembershipWhereUniqueInput!, create: MembershipCreateInput!, update: MembershipUpdateInput!): Membership!
  deleteMembership(where: MembershipWhereUniqueInput!): Membership
  deleteManyMemberships(where: MembershipWhereInput): BatchPayload!
  createMessage(data: MessageCreateInput!): Message!
  updateMessage(data: MessageUpdateInput!, where: MessageWhereUniqueInput!): Message
  updateManyMessages(data: MessageUpdateManyMutationInput!, where: MessageWhereInput): BatchPayload!
  upsertMessage(where: MessageWhereUniqueInput!, create: MessageCreateInput!, update: MessageUpdateInput!): Message!
  deleteMessage(where: MessageWhereUniqueInput!): Message
  deleteManyMessages(where: MessageWhereInput): BatchPayload!
  createProfile(data: ProfileCreateInput!): Profile!
  updateProfile(data: ProfileUpdateInput!, where: ProfileWhereUniqueInput!): Profile
  updateManyProfiles(data: ProfileUpdateManyMutationInput!, where: ProfileWhereInput): BatchPayload!
  upsertProfile(where: ProfileWhereUniqueInput!, create: ProfileCreateInput!, update: ProfileUpdateInput!): Profile!
  deleteProfile(where: ProfileWhereUniqueInput!): Profile
  deleteManyProfiles(where: ProfileWhereInput): BatchPayload!
  createReaction(data: ReactionCreateInput!): Reaction!
  updateReaction(data: ReactionUpdateInput!, where: ReactionWhereUniqueInput!): Reaction
  updateManyReactions(data: ReactionUpdateManyMutationInput!, where: ReactionWhereInput): BatchPayload!
  upsertReaction(where: ReactionWhereUniqueInput!, create: ReactionCreateInput!, update: ReactionUpdateInput!): Reaction!
  deleteReaction(where: ReactionWhereUniqueInput!): Reaction
  deleteManyReactions(where: ReactionWhereInput): BatchPayload!
  createSession(data: SessionCreateInput!): Session!
  updateSession(data: SessionUpdateInput!, where: SessionWhereUniqueInput!): Session
  updateManySessions(data: SessionUpdateManyMutationInput!, where: SessionWhereInput): BatchPayload!
  upsertSession(where: SessionWhereUniqueInput!, create: SessionCreateInput!, update: SessionUpdateInput!): Session!
  deleteSession(where: SessionWhereUniqueInput!): Session
  deleteManySessions(where: SessionWhereInput): BatchPayload!
  createTag(data: TagCreateInput!): Tag!
  updateTag(data: TagUpdateInput!, where: TagWhereUniqueInput!): Tag
  updateManyTags(data: TagUpdateManyMutationInput!, where: TagWhereInput): BatchPayload!
  upsertTag(where: TagWhereUniqueInput!, create: TagCreateInput!, update: TagUpdateInput!): Tag!
  deleteTag(where: TagWhereUniqueInput!): Tag
  deleteManyTags(where: TagWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Profile {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime
  creator: Account!
  name: String!
  timezone: String
  status: StatusType!
  type: ProfileType!
  is_hidden: Boolean!
  is_bot: Boolean!
  slogan: String
  picture: String!
  invitees(where: MembershipWhereInput, orderBy: MembershipOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Membership!]
  memberships(where: MembershipWhereInput, orderBy: MembershipOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Membership!]
}

type ProfileConnection {
  pageInfo: PageInfo!
  edges: [ProfileEdge]!
  aggregate: AggregateProfile!
}

input ProfileCreateInput {
  id: ID
  creator: AccountCreateOneWithoutProfilesInput!
  name: String!
  timezone: String
  status: StatusType!
  type: ProfileType!
  is_hidden: Boolean!
  is_bot: Boolean!
  slogan: String
  picture: String!
  invitees: MembershipCreateManyWithoutCreatorInput
  memberships: MembershipCreateManyWithoutMemberInput
}

input ProfileCreateManyWithoutCreatorInput {
  create: [ProfileCreateWithoutCreatorInput!]
  connect: [ProfileWhereUniqueInput!]
}

input ProfileCreateOneInput {
  create: ProfileCreateInput
  connect: ProfileWhereUniqueInput
}

input ProfileCreateOneWithoutInviteesInput {
  create: ProfileCreateWithoutInviteesInput
  connect: ProfileWhereUniqueInput
}

input ProfileCreateOneWithoutMembershipsInput {
  create: ProfileCreateWithoutMembershipsInput
  connect: ProfileWhereUniqueInput
}

input ProfileCreateWithoutCreatorInput {
  id: ID
  name: String!
  timezone: String
  status: StatusType!
  type: ProfileType!
  is_hidden: Boolean!
  is_bot: Boolean!
  slogan: String
  picture: String!
  invitees: MembershipCreateManyWithoutCreatorInput
  memberships: MembershipCreateManyWithoutMemberInput
}

input ProfileCreateWithoutInviteesInput {
  id: ID
  creator: AccountCreateOneWithoutProfilesInput!
  name: String!
  timezone: String
  status: StatusType!
  type: ProfileType!
  is_hidden: Boolean!
  is_bot: Boolean!
  slogan: String
  picture: String!
  memberships: MembershipCreateManyWithoutMemberInput
}

input ProfileCreateWithoutMembershipsInput {
  id: ID
  creator: AccountCreateOneWithoutProfilesInput!
  name: String!
  timezone: String
  status: StatusType!
  type: ProfileType!
  is_hidden: Boolean!
  is_bot: Boolean!
  slogan: String
  picture: String!
  invitees: MembershipCreateManyWithoutCreatorInput
}

type ProfileEdge {
  node: Profile!
  cursor: String!
}

enum ProfileOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  name_ASC
  name_DESC
  timezone_ASC
  timezone_DESC
  status_ASC
  status_DESC
  type_ASC
  type_DESC
  is_hidden_ASC
  is_hidden_DESC
  is_bot_ASC
  is_bot_DESC
  slogan_ASC
  slogan_DESC
  picture_ASC
  picture_DESC
}

type ProfilePreviousValues {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime
  name: String!
  timezone: String
  status: StatusType!
  type: ProfileType!
  is_hidden: Boolean!
  is_bot: Boolean!
  slogan: String
  picture: String!
}

input ProfileScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  timezone: String
  timezone_not: String
  timezone_in: [String!]
  timezone_not_in: [String!]
  timezone_lt: String
  timezone_lte: String
  timezone_gt: String
  timezone_gte: String
  timezone_contains: String
  timezone_not_contains: String
  timezone_starts_with: String
  timezone_not_starts_with: String
  timezone_ends_with: String
  timezone_not_ends_with: String
  status: StatusType
  status_not: StatusType
  status_in: [StatusType!]
  status_not_in: [StatusType!]
  type: ProfileType
  type_not: ProfileType
  type_in: [ProfileType!]
  type_not_in: [ProfileType!]
  is_hidden: Boolean
  is_hidden_not: Boolean
  is_bot: Boolean
  is_bot_not: Boolean
  slogan: String
  slogan_not: String
  slogan_in: [String!]
  slogan_not_in: [String!]
  slogan_lt: String
  slogan_lte: String
  slogan_gt: String
  slogan_gte: String
  slogan_contains: String
  slogan_not_contains: String
  slogan_starts_with: String
  slogan_not_starts_with: String
  slogan_ends_with: String
  slogan_not_ends_with: String
  picture: String
  picture_not: String
  picture_in: [String!]
  picture_not_in: [String!]
  picture_lt: String
  picture_lte: String
  picture_gt: String
  picture_gte: String
  picture_contains: String
  picture_not_contains: String
  picture_starts_with: String
  picture_not_starts_with: String
  picture_ends_with: String
  picture_not_ends_with: String
  AND: [ProfileScalarWhereInput!]
  OR: [ProfileScalarWhereInput!]
  NOT: [ProfileScalarWhereInput!]
}

type ProfileSubscriptionPayload {
  mutation: MutationType!
  node: Profile
  updatedFields: [String!]
  previousValues: ProfilePreviousValues
}

input ProfileSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ProfileWhereInput
  AND: [ProfileSubscriptionWhereInput!]
  OR: [ProfileSubscriptionWhereInput!]
  NOT: [ProfileSubscriptionWhereInput!]
}

enum ProfileType {
  Work
  Private
}

input ProfileUpdateDataInput {
  creator: AccountUpdateOneRequiredWithoutProfilesInput
  name: String
  timezone: String
  status: StatusType
  type: ProfileType
  is_hidden: Boolean
  is_bot: Boolean
  slogan: String
  picture: String
  invitees: MembershipUpdateManyWithoutCreatorInput
  memberships: MembershipUpdateManyWithoutMemberInput
}

input ProfileUpdateInput {
  creator: AccountUpdateOneRequiredWithoutProfilesInput
  name: String
  timezone: String
  status: StatusType
  type: ProfileType
  is_hidden: Boolean
  is_bot: Boolean
  slogan: String
  picture: String
  invitees: MembershipUpdateManyWithoutCreatorInput
  memberships: MembershipUpdateManyWithoutMemberInput
}

input ProfileUpdateManyDataInput {
  name: String
  timezone: String
  status: StatusType
  type: ProfileType
  is_hidden: Boolean
  is_bot: Boolean
  slogan: String
  picture: String
}

input ProfileUpdateManyMutationInput {
  name: String
  timezone: String
  status: StatusType
  type: ProfileType
  is_hidden: Boolean
  is_bot: Boolean
  slogan: String
  picture: String
}

input ProfileUpdateManyWithoutCreatorInput {
  create: [ProfileCreateWithoutCreatorInput!]
  delete: [ProfileWhereUniqueInput!]
  connect: [ProfileWhereUniqueInput!]
  set: [ProfileWhereUniqueInput!]
  disconnect: [ProfileWhereUniqueInput!]
  update: [ProfileUpdateWithWhereUniqueWithoutCreatorInput!]
  upsert: [ProfileUpsertWithWhereUniqueWithoutCreatorInput!]
  deleteMany: [ProfileScalarWhereInput!]
  updateMany: [ProfileUpdateManyWithWhereNestedInput!]
}

input ProfileUpdateManyWithWhereNestedInput {
  where: ProfileScalarWhereInput!
  data: ProfileUpdateManyDataInput!
}

input ProfileUpdateOneInput {
  create: ProfileCreateInput
  update: ProfileUpdateDataInput
  upsert: ProfileUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: ProfileWhereUniqueInput
}

input ProfileUpdateOneRequiredInput {
  create: ProfileCreateInput
  update: ProfileUpdateDataInput
  upsert: ProfileUpsertNestedInput
  connect: ProfileWhereUniqueInput
}

input ProfileUpdateOneRequiredWithoutInviteesInput {
  create: ProfileCreateWithoutInviteesInput
  update: ProfileUpdateWithoutInviteesDataInput
  upsert: ProfileUpsertWithoutInviteesInput
  connect: ProfileWhereUniqueInput
}

input ProfileUpdateOneRequiredWithoutMembershipsInput {
  create: ProfileCreateWithoutMembershipsInput
  update: ProfileUpdateWithoutMembershipsDataInput
  upsert: ProfileUpsertWithoutMembershipsInput
  connect: ProfileWhereUniqueInput
}

input ProfileUpdateWithoutCreatorDataInput {
  name: String
  timezone: String
  status: StatusType
  type: ProfileType
  is_hidden: Boolean
  is_bot: Boolean
  slogan: String
  picture: String
  invitees: MembershipUpdateManyWithoutCreatorInput
  memberships: MembershipUpdateManyWithoutMemberInput
}

input ProfileUpdateWithoutInviteesDataInput {
  creator: AccountUpdateOneRequiredWithoutProfilesInput
  name: String
  timezone: String
  status: StatusType
  type: ProfileType
  is_hidden: Boolean
  is_bot: Boolean
  slogan: String
  picture: String
  memberships: MembershipUpdateManyWithoutMemberInput
}

input ProfileUpdateWithoutMembershipsDataInput {
  creator: AccountUpdateOneRequiredWithoutProfilesInput
  name: String
  timezone: String
  status: StatusType
  type: ProfileType
  is_hidden: Boolean
  is_bot: Boolean
  slogan: String
  picture: String
  invitees: MembershipUpdateManyWithoutCreatorInput
}

input ProfileUpdateWithWhereUniqueWithoutCreatorInput {
  where: ProfileWhereUniqueInput!
  data: ProfileUpdateWithoutCreatorDataInput!
}

input ProfileUpsertNestedInput {
  update: ProfileUpdateDataInput!
  create: ProfileCreateInput!
}

input ProfileUpsertWithoutInviteesInput {
  update: ProfileUpdateWithoutInviteesDataInput!
  create: ProfileCreateWithoutInviteesInput!
}

input ProfileUpsertWithoutMembershipsInput {
  update: ProfileUpdateWithoutMembershipsDataInput!
  create: ProfileCreateWithoutMembershipsInput!
}

input ProfileUpsertWithWhereUniqueWithoutCreatorInput {
  where: ProfileWhereUniqueInput!
  update: ProfileUpdateWithoutCreatorDataInput!
  create: ProfileCreateWithoutCreatorInput!
}

input ProfileWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  creator: AccountWhereInput
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  timezone: String
  timezone_not: String
  timezone_in: [String!]
  timezone_not_in: [String!]
  timezone_lt: String
  timezone_lte: String
  timezone_gt: String
  timezone_gte: String
  timezone_contains: String
  timezone_not_contains: String
  timezone_starts_with: String
  timezone_not_starts_with: String
  timezone_ends_with: String
  timezone_not_ends_with: String
  status: StatusType
  status_not: StatusType
  status_in: [StatusType!]
  status_not_in: [StatusType!]
  type: ProfileType
  type_not: ProfileType
  type_in: [ProfileType!]
  type_not_in: [ProfileType!]
  is_hidden: Boolean
  is_hidden_not: Boolean
  is_bot: Boolean
  is_bot_not: Boolean
  slogan: String
  slogan_not: String
  slogan_in: [String!]
  slogan_not_in: [String!]
  slogan_lt: String
  slogan_lte: String
  slogan_gt: String
  slogan_gte: String
  slogan_contains: String
  slogan_not_contains: String
  slogan_starts_with: String
  slogan_not_starts_with: String
  slogan_ends_with: String
  slogan_not_ends_with: String
  picture: String
  picture_not: String
  picture_in: [String!]
  picture_not_in: [String!]
  picture_lt: String
  picture_lte: String
  picture_gt: String
  picture_gte: String
  picture_contains: String
  picture_not_contains: String
  picture_starts_with: String
  picture_not_starts_with: String
  picture_ends_with: String
  picture_not_ends_with: String
  invitees_every: MembershipWhereInput
  invitees_some: MembershipWhereInput
  invitees_none: MembershipWhereInput
  memberships_every: MembershipWhereInput
  memberships_some: MembershipWhereInput
  memberships_none: MembershipWhereInput
  AND: [ProfileWhereInput!]
  OR: [ProfileWhereInput!]
  NOT: [ProfileWhereInput!]
}

input ProfileWhereUniqueInput {
  id: ID
}

type Query {
  account(where: AccountWhereUniqueInput!): Account
  accounts(where: AccountWhereInput, orderBy: AccountOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Account]!
  accountsConnection(where: AccountWhereInput, orderBy: AccountOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): AccountConnection!
  attachment(where: AttachmentWhereUniqueInput!): Attachment
  attachments(where: AttachmentWhereInput, orderBy: AttachmentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Attachment]!
  attachmentsConnection(where: AttachmentWhereInput, orderBy: AttachmentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): AttachmentConnection!
  group(where: GroupWhereUniqueInput!): Group
  groups(where: GroupWhereInput, orderBy: GroupOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Group]!
  groupsConnection(where: GroupWhereInput, orderBy: GroupOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): GroupConnection!
  location(where: LocationWhereUniqueInput!): Location
  locations(where: LocationWhereInput, orderBy: LocationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Location]!
  locationsConnection(where: LocationWhereInput, orderBy: LocationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): LocationConnection!
  membership(where: MembershipWhereUniqueInput!): Membership
  memberships(where: MembershipWhereInput, orderBy: MembershipOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Membership]!
  membershipsConnection(where: MembershipWhereInput, orderBy: MembershipOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): MembershipConnection!
  message(where: MessageWhereUniqueInput!): Message
  messages(where: MessageWhereInput, orderBy: MessageOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Message]!
  messagesConnection(where: MessageWhereInput, orderBy: MessageOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): MessageConnection!
  profile(where: ProfileWhereUniqueInput!): Profile
  profiles(where: ProfileWhereInput, orderBy: ProfileOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Profile]!
  profilesConnection(where: ProfileWhereInput, orderBy: ProfileOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ProfileConnection!
  reaction(where: ReactionWhereUniqueInput!): Reaction
  reactions(where: ReactionWhereInput, orderBy: ReactionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Reaction]!
  reactionsConnection(where: ReactionWhereInput, orderBy: ReactionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ReactionConnection!
  session(where: SessionWhereUniqueInput!): Session
  sessions(where: SessionWhereInput, orderBy: SessionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Session]!
  sessionsConnection(where: SessionWhereInput, orderBy: SessionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): SessionConnection!
  tag(where: TagWhereUniqueInput!): Tag
  tags(where: TagWhereInput, orderBy: TagOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Tag]!
  tagsConnection(where: TagWhereInput, orderBy: TagOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): TagConnection!
  node(id: ID!): Node
}

type Reaction {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime
  creator: Profile!
  emoji: String!
}

type ReactionConnection {
  pageInfo: PageInfo!
  edges: [ReactionEdge]!
  aggregate: AggregateReaction!
}

input ReactionCreateInput {
  id: ID
  creator: ProfileCreateOneInput!
  emoji: String!
}

input ReactionCreateManyInput {
  create: [ReactionCreateInput!]
  connect: [ReactionWhereUniqueInput!]
}

type ReactionEdge {
  node: Reaction!
  cursor: String!
}

enum ReactionOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  emoji_ASC
  emoji_DESC
}

type ReactionPreviousValues {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime
  emoji: String!
}

input ReactionScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  emoji: String
  emoji_not: String
  emoji_in: [String!]
  emoji_not_in: [String!]
  emoji_lt: String
  emoji_lte: String
  emoji_gt: String
  emoji_gte: String
  emoji_contains: String
  emoji_not_contains: String
  emoji_starts_with: String
  emoji_not_starts_with: String
  emoji_ends_with: String
  emoji_not_ends_with: String
  AND: [ReactionScalarWhereInput!]
  OR: [ReactionScalarWhereInput!]
  NOT: [ReactionScalarWhereInput!]
}

type ReactionSubscriptionPayload {
  mutation: MutationType!
  node: Reaction
  updatedFields: [String!]
  previousValues: ReactionPreviousValues
}

input ReactionSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ReactionWhereInput
  AND: [ReactionSubscriptionWhereInput!]
  OR: [ReactionSubscriptionWhereInput!]
  NOT: [ReactionSubscriptionWhereInput!]
}

input ReactionUpdateDataInput {
  creator: ProfileUpdateOneRequiredInput
  emoji: String
}

input ReactionUpdateInput {
  creator: ProfileUpdateOneRequiredInput
  emoji: String
}

input ReactionUpdateManyDataInput {
  emoji: String
}

input ReactionUpdateManyInput {
  create: [ReactionCreateInput!]
  update: [ReactionUpdateWithWhereUniqueNestedInput!]
  upsert: [ReactionUpsertWithWhereUniqueNestedInput!]
  delete: [ReactionWhereUniqueInput!]
  connect: [ReactionWhereUniqueInput!]
  set: [ReactionWhereUniqueInput!]
  disconnect: [ReactionWhereUniqueInput!]
  deleteMany: [ReactionScalarWhereInput!]
  updateMany: [ReactionUpdateManyWithWhereNestedInput!]
}

input ReactionUpdateManyMutationInput {
  emoji: String
}

input ReactionUpdateManyWithWhereNestedInput {
  where: ReactionScalarWhereInput!
  data: ReactionUpdateManyDataInput!
}

input ReactionUpdateWithWhereUniqueNestedInput {
  where: ReactionWhereUniqueInput!
  data: ReactionUpdateDataInput!
}

input ReactionUpsertWithWhereUniqueNestedInput {
  where: ReactionWhereUniqueInput!
  update: ReactionUpdateDataInput!
  create: ReactionCreateInput!
}

input ReactionWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  creator: ProfileWhereInput
  emoji: String
  emoji_not: String
  emoji_in: [String!]
  emoji_not_in: [String!]
  emoji_lt: String
  emoji_lte: String
  emoji_gt: String
  emoji_gte: String
  emoji_contains: String
  emoji_not_contains: String
  emoji_starts_with: String
  emoji_not_starts_with: String
  emoji_ends_with: String
  emoji_not_ends_with: String
  AND: [ReactionWhereInput!]
  OR: [ReactionWhereInput!]
  NOT: [ReactionWhereInput!]
}

input ReactionWhereUniqueInput {
  id: ID
}

type Session {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime
  csrfToken: String!
  authToken: String!
  validTo: DateTime!
  timedOut: DateTime
  loggedOut: DateTime
  account: Account!
  profile: Profile
  location: Location
  lastIpAddress: String
}

type SessionConnection {
  pageInfo: PageInfo!
  edges: [SessionEdge]!
  aggregate: AggregateSession!
}

input SessionCreateInput {
  id: ID
  csrfToken: String!
  authToken: String!
  validTo: DateTime!
  timedOut: DateTime
  loggedOut: DateTime
  account: AccountCreateOneWithoutSessionsInput!
  profile: ProfileCreateOneInput
  location: LocationCreateOneInput
  lastIpAddress: String
}

input SessionCreateManyWithoutAccountInput {
  create: [SessionCreateWithoutAccountInput!]
  connect: [SessionWhereUniqueInput!]
}

input SessionCreateWithoutAccountInput {
  id: ID
  csrfToken: String!
  authToken: String!
  validTo: DateTime!
  timedOut: DateTime
  loggedOut: DateTime
  profile: ProfileCreateOneInput
  location: LocationCreateOneInput
  lastIpAddress: String
}

type SessionEdge {
  node: Session!
  cursor: String!
}

enum SessionOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  csrfToken_ASC
  csrfToken_DESC
  authToken_ASC
  authToken_DESC
  validTo_ASC
  validTo_DESC
  timedOut_ASC
  timedOut_DESC
  loggedOut_ASC
  loggedOut_DESC
  lastIpAddress_ASC
  lastIpAddress_DESC
}

type SessionPreviousValues {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime
  csrfToken: String!
  authToken: String!
  validTo: DateTime!
  timedOut: DateTime
  loggedOut: DateTime
  lastIpAddress: String
}

input SessionScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  csrfToken: String
  csrfToken_not: String
  csrfToken_in: [String!]
  csrfToken_not_in: [String!]
  csrfToken_lt: String
  csrfToken_lte: String
  csrfToken_gt: String
  csrfToken_gte: String
  csrfToken_contains: String
  csrfToken_not_contains: String
  csrfToken_starts_with: String
  csrfToken_not_starts_with: String
  csrfToken_ends_with: String
  csrfToken_not_ends_with: String
  authToken: String
  authToken_not: String
  authToken_in: [String!]
  authToken_not_in: [String!]
  authToken_lt: String
  authToken_lte: String
  authToken_gt: String
  authToken_gte: String
  authToken_contains: String
  authToken_not_contains: String
  authToken_starts_with: String
  authToken_not_starts_with: String
  authToken_ends_with: String
  authToken_not_ends_with: String
  validTo: DateTime
  validTo_not: DateTime
  validTo_in: [DateTime!]
  validTo_not_in: [DateTime!]
  validTo_lt: DateTime
  validTo_lte: DateTime
  validTo_gt: DateTime
  validTo_gte: DateTime
  timedOut: DateTime
  timedOut_not: DateTime
  timedOut_in: [DateTime!]
  timedOut_not_in: [DateTime!]
  timedOut_lt: DateTime
  timedOut_lte: DateTime
  timedOut_gt: DateTime
  timedOut_gte: DateTime
  loggedOut: DateTime
  loggedOut_not: DateTime
  loggedOut_in: [DateTime!]
  loggedOut_not_in: [DateTime!]
  loggedOut_lt: DateTime
  loggedOut_lte: DateTime
  loggedOut_gt: DateTime
  loggedOut_gte: DateTime
  lastIpAddress: String
  lastIpAddress_not: String
  lastIpAddress_in: [String!]
  lastIpAddress_not_in: [String!]
  lastIpAddress_lt: String
  lastIpAddress_lte: String
  lastIpAddress_gt: String
  lastIpAddress_gte: String
  lastIpAddress_contains: String
  lastIpAddress_not_contains: String
  lastIpAddress_starts_with: String
  lastIpAddress_not_starts_with: String
  lastIpAddress_ends_with: String
  lastIpAddress_not_ends_with: String
  AND: [SessionScalarWhereInput!]
  OR: [SessionScalarWhereInput!]
  NOT: [SessionScalarWhereInput!]
}

type SessionSubscriptionPayload {
  mutation: MutationType!
  node: Session
  updatedFields: [String!]
  previousValues: SessionPreviousValues
}

input SessionSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: SessionWhereInput
  AND: [SessionSubscriptionWhereInput!]
  OR: [SessionSubscriptionWhereInput!]
  NOT: [SessionSubscriptionWhereInput!]
}

input SessionUpdateInput {
  csrfToken: String
  authToken: String
  validTo: DateTime
  timedOut: DateTime
  loggedOut: DateTime
  account: AccountUpdateOneRequiredWithoutSessionsInput
  profile: ProfileUpdateOneInput
  location: LocationUpdateOneInput
  lastIpAddress: String
}

input SessionUpdateManyDataInput {
  csrfToken: String
  authToken: String
  validTo: DateTime
  timedOut: DateTime
  loggedOut: DateTime
  lastIpAddress: String
}

input SessionUpdateManyMutationInput {
  csrfToken: String
  authToken: String
  validTo: DateTime
  timedOut: DateTime
  loggedOut: DateTime
  lastIpAddress: String
}

input SessionUpdateManyWithoutAccountInput {
  create: [SessionCreateWithoutAccountInput!]
  delete: [SessionWhereUniqueInput!]
  connect: [SessionWhereUniqueInput!]
  set: [SessionWhereUniqueInput!]
  disconnect: [SessionWhereUniqueInput!]
  update: [SessionUpdateWithWhereUniqueWithoutAccountInput!]
  upsert: [SessionUpsertWithWhereUniqueWithoutAccountInput!]
  deleteMany: [SessionScalarWhereInput!]
  updateMany: [SessionUpdateManyWithWhereNestedInput!]
}

input SessionUpdateManyWithWhereNestedInput {
  where: SessionScalarWhereInput!
  data: SessionUpdateManyDataInput!
}

input SessionUpdateWithoutAccountDataInput {
  csrfToken: String
  authToken: String
  validTo: DateTime
  timedOut: DateTime
  loggedOut: DateTime
  profile: ProfileUpdateOneInput
  location: LocationUpdateOneInput
  lastIpAddress: String
}

input SessionUpdateWithWhereUniqueWithoutAccountInput {
  where: SessionWhereUniqueInput!
  data: SessionUpdateWithoutAccountDataInput!
}

input SessionUpsertWithWhereUniqueWithoutAccountInput {
  where: SessionWhereUniqueInput!
  update: SessionUpdateWithoutAccountDataInput!
  create: SessionCreateWithoutAccountInput!
}

input SessionWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  csrfToken: String
  csrfToken_not: String
  csrfToken_in: [String!]
  csrfToken_not_in: [String!]
  csrfToken_lt: String
  csrfToken_lte: String
  csrfToken_gt: String
  csrfToken_gte: String
  csrfToken_contains: String
  csrfToken_not_contains: String
  csrfToken_starts_with: String
  csrfToken_not_starts_with: String
  csrfToken_ends_with: String
  csrfToken_not_ends_with: String
  authToken: String
  authToken_not: String
  authToken_in: [String!]
  authToken_not_in: [String!]
  authToken_lt: String
  authToken_lte: String
  authToken_gt: String
  authToken_gte: String
  authToken_contains: String
  authToken_not_contains: String
  authToken_starts_with: String
  authToken_not_starts_with: String
  authToken_ends_with: String
  authToken_not_ends_with: String
  validTo: DateTime
  validTo_not: DateTime
  validTo_in: [DateTime!]
  validTo_not_in: [DateTime!]
  validTo_lt: DateTime
  validTo_lte: DateTime
  validTo_gt: DateTime
  validTo_gte: DateTime
  timedOut: DateTime
  timedOut_not: DateTime
  timedOut_in: [DateTime!]
  timedOut_not_in: [DateTime!]
  timedOut_lt: DateTime
  timedOut_lte: DateTime
  timedOut_gt: DateTime
  timedOut_gte: DateTime
  loggedOut: DateTime
  loggedOut_not: DateTime
  loggedOut_in: [DateTime!]
  loggedOut_not_in: [DateTime!]
  loggedOut_lt: DateTime
  loggedOut_lte: DateTime
  loggedOut_gt: DateTime
  loggedOut_gte: DateTime
  account: AccountWhereInput
  profile: ProfileWhereInput
  location: LocationWhereInput
  lastIpAddress: String
  lastIpAddress_not: String
  lastIpAddress_in: [String!]
  lastIpAddress_not_in: [String!]
  lastIpAddress_lt: String
  lastIpAddress_lte: String
  lastIpAddress_gt: String
  lastIpAddress_gte: String
  lastIpAddress_contains: String
  lastIpAddress_not_contains: String
  lastIpAddress_starts_with: String
  lastIpAddress_not_starts_with: String
  lastIpAddress_ends_with: String
  lastIpAddress_not_ends_with: String
  AND: [SessionWhereInput!]
  OR: [SessionWhereInput!]
  NOT: [SessionWhereInput!]
}

input SessionWhereUniqueInput {
  id: ID
  csrfToken: String
  authToken: String
}

enum StatusType {
  Busy
  Offline
  Online
  Away
}

type Subscription {
  account(where: AccountSubscriptionWhereInput): AccountSubscriptionPayload
  attachment(where: AttachmentSubscriptionWhereInput): AttachmentSubscriptionPayload
  group(where: GroupSubscriptionWhereInput): GroupSubscriptionPayload
  location(where: LocationSubscriptionWhereInput): LocationSubscriptionPayload
  membership(where: MembershipSubscriptionWhereInput): MembershipSubscriptionPayload
  message(where: MessageSubscriptionWhereInput): MessageSubscriptionPayload
  profile(where: ProfileSubscriptionWhereInput): ProfileSubscriptionPayload
  reaction(where: ReactionSubscriptionWhereInput): ReactionSubscriptionPayload
  session(where: SessionSubscriptionWhereInput): SessionSubscriptionPayload
  tag(where: TagSubscriptionWhereInput): TagSubscriptionPayload
}

type Tag {
  id: ID!
  createdAt: DateTime!
  creator: Profile!
  name: String!
  parent: Tag
}

type TagConnection {
  pageInfo: PageInfo!
  edges: [TagEdge]!
  aggregate: AggregateTag!
}

input TagCreateInput {
  id: ID
  creator: ProfileCreateOneInput!
  name: String!
  parent: TagCreateOneInput
}

input TagCreateManyInput {
  create: [TagCreateInput!]
  connect: [TagWhereUniqueInput!]
}

input TagCreateOneInput {
  create: TagCreateInput
  connect: TagWhereUniqueInput
}

type TagEdge {
  node: Tag!
  cursor: String!
}

enum TagOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  name_ASC
  name_DESC
}

type TagPreviousValues {
  id: ID!
  createdAt: DateTime!
  name: String!
}

input TagScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  AND: [TagScalarWhereInput!]
  OR: [TagScalarWhereInput!]
  NOT: [TagScalarWhereInput!]
}

type TagSubscriptionPayload {
  mutation: MutationType!
  node: Tag
  updatedFields: [String!]
  previousValues: TagPreviousValues
}

input TagSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: TagWhereInput
  AND: [TagSubscriptionWhereInput!]
  OR: [TagSubscriptionWhereInput!]
  NOT: [TagSubscriptionWhereInput!]
}

input TagUpdateDataInput {
  creator: ProfileUpdateOneRequiredInput
  name: String
  parent: TagUpdateOneInput
}

input TagUpdateInput {
  creator: ProfileUpdateOneRequiredInput
  name: String
  parent: TagUpdateOneInput
}

input TagUpdateManyDataInput {
  name: String
}

input TagUpdateManyInput {
  create: [TagCreateInput!]
  update: [TagUpdateWithWhereUniqueNestedInput!]
  upsert: [TagUpsertWithWhereUniqueNestedInput!]
  delete: [TagWhereUniqueInput!]
  connect: [TagWhereUniqueInput!]
  set: [TagWhereUniqueInput!]
  disconnect: [TagWhereUniqueInput!]
  deleteMany: [TagScalarWhereInput!]
  updateMany: [TagUpdateManyWithWhereNestedInput!]
}

input TagUpdateManyMutationInput {
  name: String
}

input TagUpdateManyWithWhereNestedInput {
  where: TagScalarWhereInput!
  data: TagUpdateManyDataInput!
}

input TagUpdateOneInput {
  create: TagCreateInput
  update: TagUpdateDataInput
  upsert: TagUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: TagWhereUniqueInput
}

input TagUpdateWithWhereUniqueNestedInput {
  where: TagWhereUniqueInput!
  data: TagUpdateDataInput!
}

input TagUpsertNestedInput {
  update: TagUpdateDataInput!
  create: TagCreateInput!
}

input TagUpsertWithWhereUniqueNestedInput {
  where: TagWhereUniqueInput!
  update: TagUpdateDataInput!
  create: TagCreateInput!
}

input TagWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  creator: ProfileWhereInput
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  parent: TagWhereInput
  AND: [TagWhereInput!]
  OR: [TagWhereInput!]
  NOT: [TagWhereInput!]
}

input TagWhereUniqueInput {
  id: ID
}
`