// Code generated by Prisma (prisma@1.34.10). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

export const typeDefs = /* GraphQL */ `type Agent {
  id: ID!
  type: AgentType!
  implementation: String!
  owner: ID!
  createdBy: ID!
  createdAt: DateTime!
  updatedBy: ID
  updatedAt: DateTime
  name: String!
  status: AgentStatus!
  timezone: String
  location: Location
  profileSlogan: String
  profileAvatar: String
  profileJobTitle: String
  profileBanner: String
  profileType: ProfileType
  serviceDescription: String
  inboxDescription: String
}

type AgentConnection {
  pageInfo: PageInfo!
  edges: [AgentEdge]!
  aggregate: AggregateAgent!
}

input AgentCreateInput {
  id: ID
  type: AgentType!
  implementation: String!
  owner: ID!
  createdBy: ID!
  updatedBy: ID
  name: String!
  status: AgentStatus!
  timezone: String
  location: LocationCreateOneInput
  profileSlogan: String
  profileAvatar: String
  profileJobTitle: String
  profileBanner: String
  profileType: ProfileType
  serviceDescription: String
  inboxDescription: String
}

input AgentCreateManyInput {
  create: [AgentCreateInput!]
  connect: [AgentWhereUniqueInput!]
}

input AgentCreateOneInput {
  create: AgentCreateInput
  connect: AgentWhereUniqueInput
}

type AgentEdge {
  node: Agent!
  cursor: String!
}

enum AgentOrderByInput {
  id_ASC
  id_DESC
  type_ASC
  type_DESC
  implementation_ASC
  implementation_DESC
  owner_ASC
  owner_DESC
  createdBy_ASC
  createdBy_DESC
  createdAt_ASC
  createdAt_DESC
  updatedBy_ASC
  updatedBy_DESC
  updatedAt_ASC
  updatedAt_DESC
  name_ASC
  name_DESC
  status_ASC
  status_DESC
  timezone_ASC
  timezone_DESC
  profileSlogan_ASC
  profileSlogan_DESC
  profileAvatar_ASC
  profileAvatar_DESC
  profileJobTitle_ASC
  profileJobTitle_DESC
  profileBanner_ASC
  profileBanner_DESC
  profileType_ASC
  profileType_DESC
  serviceDescription_ASC
  serviceDescription_DESC
  inboxDescription_ASC
  inboxDescription_DESC
}

type AgentPreviousValues {
  id: ID!
  type: AgentType!
  implementation: String!
  owner: ID!
  createdBy: ID!
  createdAt: DateTime!
  updatedBy: ID
  updatedAt: DateTime
  name: String!
  status: AgentStatus!
  timezone: String
  profileSlogan: String
  profileAvatar: String
  profileJobTitle: String
  profileBanner: String
  profileType: ProfileType
  serviceDescription: String
  inboxDescription: String
}

input AgentScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  type: AgentType
  type_not: AgentType
  type_in: [AgentType!]
  type_not_in: [AgentType!]
  implementation: String
  implementation_not: String
  implementation_in: [String!]
  implementation_not_in: [String!]
  implementation_lt: String
  implementation_lte: String
  implementation_gt: String
  implementation_gte: String
  implementation_contains: String
  implementation_not_contains: String
  implementation_starts_with: String
  implementation_not_starts_with: String
  implementation_ends_with: String
  implementation_not_ends_with: String
  owner: ID
  owner_not: ID
  owner_in: [ID!]
  owner_not_in: [ID!]
  owner_lt: ID
  owner_lte: ID
  owner_gt: ID
  owner_gte: ID
  owner_contains: ID
  owner_not_contains: ID
  owner_starts_with: ID
  owner_not_starts_with: ID
  owner_ends_with: ID
  owner_not_ends_with: ID
  createdBy: ID
  createdBy_not: ID
  createdBy_in: [ID!]
  createdBy_not_in: [ID!]
  createdBy_lt: ID
  createdBy_lte: ID
  createdBy_gt: ID
  createdBy_gte: ID
  createdBy_contains: ID
  createdBy_not_contains: ID
  createdBy_starts_with: ID
  createdBy_not_starts_with: ID
  createdBy_ends_with: ID
  createdBy_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedBy: ID
  updatedBy_not: ID
  updatedBy_in: [ID!]
  updatedBy_not_in: [ID!]
  updatedBy_lt: ID
  updatedBy_lte: ID
  updatedBy_gt: ID
  updatedBy_gte: ID
  updatedBy_contains: ID
  updatedBy_not_contains: ID
  updatedBy_starts_with: ID
  updatedBy_not_starts_with: ID
  updatedBy_ends_with: ID
  updatedBy_not_ends_with: ID
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  status: AgentStatus
  status_not: AgentStatus
  status_in: [AgentStatus!]
  status_not_in: [AgentStatus!]
  timezone: String
  timezone_not: String
  timezone_in: [String!]
  timezone_not_in: [String!]
  timezone_lt: String
  timezone_lte: String
  timezone_gt: String
  timezone_gte: String
  timezone_contains: String
  timezone_not_contains: String
  timezone_starts_with: String
  timezone_not_starts_with: String
  timezone_ends_with: String
  timezone_not_ends_with: String
  profileSlogan: String
  profileSlogan_not: String
  profileSlogan_in: [String!]
  profileSlogan_not_in: [String!]
  profileSlogan_lt: String
  profileSlogan_lte: String
  profileSlogan_gt: String
  profileSlogan_gte: String
  profileSlogan_contains: String
  profileSlogan_not_contains: String
  profileSlogan_starts_with: String
  profileSlogan_not_starts_with: String
  profileSlogan_ends_with: String
  profileSlogan_not_ends_with: String
  profileAvatar: String
  profileAvatar_not: String
  profileAvatar_in: [String!]
  profileAvatar_not_in: [String!]
  profileAvatar_lt: String
  profileAvatar_lte: String
  profileAvatar_gt: String
  profileAvatar_gte: String
  profileAvatar_contains: String
  profileAvatar_not_contains: String
  profileAvatar_starts_with: String
  profileAvatar_not_starts_with: String
  profileAvatar_ends_with: String
  profileAvatar_not_ends_with: String
  profileJobTitle: String
  profileJobTitle_not: String
  profileJobTitle_in: [String!]
  profileJobTitle_not_in: [String!]
  profileJobTitle_lt: String
  profileJobTitle_lte: String
  profileJobTitle_gt: String
  profileJobTitle_gte: String
  profileJobTitle_contains: String
  profileJobTitle_not_contains: String
  profileJobTitle_starts_with: String
  profileJobTitle_not_starts_with: String
  profileJobTitle_ends_with: String
  profileJobTitle_not_ends_with: String
  profileBanner: String
  profileBanner_not: String
  profileBanner_in: [String!]
  profileBanner_not_in: [String!]
  profileBanner_lt: String
  profileBanner_lte: String
  profileBanner_gt: String
  profileBanner_gte: String
  profileBanner_contains: String
  profileBanner_not_contains: String
  profileBanner_starts_with: String
  profileBanner_not_starts_with: String
  profileBanner_ends_with: String
  profileBanner_not_ends_with: String
  profileType: ProfileType
  profileType_not: ProfileType
  profileType_in: [ProfileType!]
  profileType_not_in: [ProfileType!]
  serviceDescription: String
  serviceDescription_not: String
  serviceDescription_in: [String!]
  serviceDescription_not_in: [String!]
  serviceDescription_lt: String
  serviceDescription_lte: String
  serviceDescription_gt: String
  serviceDescription_gte: String
  serviceDescription_contains: String
  serviceDescription_not_contains: String
  serviceDescription_starts_with: String
  serviceDescription_not_starts_with: String
  serviceDescription_ends_with: String
  serviceDescription_not_ends_with: String
  inboxDescription: String
  inboxDescription_not: String
  inboxDescription_in: [String!]
  inboxDescription_not_in: [String!]
  inboxDescription_lt: String
  inboxDescription_lte: String
  inboxDescription_gt: String
  inboxDescription_gte: String
  inboxDescription_contains: String
  inboxDescription_not_contains: String
  inboxDescription_starts_with: String
  inboxDescription_not_starts_with: String
  inboxDescription_ends_with: String
  inboxDescription_not_ends_with: String
  AND: [AgentScalarWhereInput!]
  OR: [AgentScalarWhereInput!]
  NOT: [AgentScalarWhereInput!]
}

enum AgentStatus {
  Offline
  DoNotDisturb
  Away
  Available
  Running
  Suspended
  Failed
  Succeeded
  Open
  Closed
}

type AgentSubscriptionPayload {
  mutation: MutationType!
  node: Agent
  updatedFields: [String!]
  previousValues: AgentPreviousValues
}

input AgentSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: AgentWhereInput
  AND: [AgentSubscriptionWhereInput!]
  OR: [AgentSubscriptionWhereInput!]
  NOT: [AgentSubscriptionWhereInput!]
}

enum AgentType {
  Profile
  Service
  Inbox
}

input AgentUpdateDataInput {
  type: AgentType
  implementation: String
  owner: ID
  createdBy: ID
  updatedBy: ID
  name: String
  status: AgentStatus
  timezone: String
  location: LocationUpdateOneInput
  profileSlogan: String
  profileAvatar: String
  profileJobTitle: String
  profileBanner: String
  profileType: ProfileType
  serviceDescription: String
  inboxDescription: String
}

input AgentUpdateInput {
  type: AgentType
  implementation: String
  owner: ID
  createdBy: ID
  updatedBy: ID
  name: String
  status: AgentStatus
  timezone: String
  location: LocationUpdateOneInput
  profileSlogan: String
  profileAvatar: String
  profileJobTitle: String
  profileBanner: String
  profileType: ProfileType
  serviceDescription: String
  inboxDescription: String
}

input AgentUpdateManyDataInput {
  type: AgentType
  implementation: String
  owner: ID
  createdBy: ID
  updatedBy: ID
  name: String
  status: AgentStatus
  timezone: String
  profileSlogan: String
  profileAvatar: String
  profileJobTitle: String
  profileBanner: String
  profileType: ProfileType
  serviceDescription: String
  inboxDescription: String
}

input AgentUpdateManyInput {
  create: [AgentCreateInput!]
  update: [AgentUpdateWithWhereUniqueNestedInput!]
  upsert: [AgentUpsertWithWhereUniqueNestedInput!]
  delete: [AgentWhereUniqueInput!]
  connect: [AgentWhereUniqueInput!]
  set: [AgentWhereUniqueInput!]
  disconnect: [AgentWhereUniqueInput!]
  deleteMany: [AgentScalarWhereInput!]
  updateMany: [AgentUpdateManyWithWhereNestedInput!]
}

input AgentUpdateManyMutationInput {
  type: AgentType
  implementation: String
  owner: ID
  createdBy: ID
  updatedBy: ID
  name: String
  status: AgentStatus
  timezone: String
  profileSlogan: String
  profileAvatar: String
  profileJobTitle: String
  profileBanner: String
  profileType: ProfileType
  serviceDescription: String
  inboxDescription: String
}

input AgentUpdateManyWithWhereNestedInput {
  where: AgentScalarWhereInput!
  data: AgentUpdateManyDataInput!
}

input AgentUpdateOneRequiredInput {
  create: AgentCreateInput
  update: AgentUpdateDataInput
  upsert: AgentUpsertNestedInput
  connect: AgentWhereUniqueInput
}

input AgentUpdateWithWhereUniqueNestedInput {
  where: AgentWhereUniqueInput!
  data: AgentUpdateDataInput!
}

input AgentUpsertNestedInput {
  update: AgentUpdateDataInput!
  create: AgentCreateInput!
}

input AgentUpsertWithWhereUniqueNestedInput {
  where: AgentWhereUniqueInput!
  update: AgentUpdateDataInput!
  create: AgentCreateInput!
}

input AgentWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  type: AgentType
  type_not: AgentType
  type_in: [AgentType!]
  type_not_in: [AgentType!]
  implementation: String
  implementation_not: String
  implementation_in: [String!]
  implementation_not_in: [String!]
  implementation_lt: String
  implementation_lte: String
  implementation_gt: String
  implementation_gte: String
  implementation_contains: String
  implementation_not_contains: String
  implementation_starts_with: String
  implementation_not_starts_with: String
  implementation_ends_with: String
  implementation_not_ends_with: String
  owner: ID
  owner_not: ID
  owner_in: [ID!]
  owner_not_in: [ID!]
  owner_lt: ID
  owner_lte: ID
  owner_gt: ID
  owner_gte: ID
  owner_contains: ID
  owner_not_contains: ID
  owner_starts_with: ID
  owner_not_starts_with: ID
  owner_ends_with: ID
  owner_not_ends_with: ID
  createdBy: ID
  createdBy_not: ID
  createdBy_in: [ID!]
  createdBy_not_in: [ID!]
  createdBy_lt: ID
  createdBy_lte: ID
  createdBy_gt: ID
  createdBy_gte: ID
  createdBy_contains: ID
  createdBy_not_contains: ID
  createdBy_starts_with: ID
  createdBy_not_starts_with: ID
  createdBy_ends_with: ID
  createdBy_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedBy: ID
  updatedBy_not: ID
  updatedBy_in: [ID!]
  updatedBy_not_in: [ID!]
  updatedBy_lt: ID
  updatedBy_lte: ID
  updatedBy_gt: ID
  updatedBy_gte: ID
  updatedBy_contains: ID
  updatedBy_not_contains: ID
  updatedBy_starts_with: ID
  updatedBy_not_starts_with: ID
  updatedBy_ends_with: ID
  updatedBy_not_ends_with: ID
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  status: AgentStatus
  status_not: AgentStatus
  status_in: [AgentStatus!]
  status_not_in: [AgentStatus!]
  timezone: String
  timezone_not: String
  timezone_in: [String!]
  timezone_not_in: [String!]
  timezone_lt: String
  timezone_lte: String
  timezone_gt: String
  timezone_gte: String
  timezone_contains: String
  timezone_not_contains: String
  timezone_starts_with: String
  timezone_not_starts_with: String
  timezone_ends_with: String
  timezone_not_ends_with: String
  location: LocationWhereInput
  profileSlogan: String
  profileSlogan_not: String
  profileSlogan_in: [String!]
  profileSlogan_not_in: [String!]
  profileSlogan_lt: String
  profileSlogan_lte: String
  profileSlogan_gt: String
  profileSlogan_gte: String
  profileSlogan_contains: String
  profileSlogan_not_contains: String
  profileSlogan_starts_with: String
  profileSlogan_not_starts_with: String
  profileSlogan_ends_with: String
  profileSlogan_not_ends_with: String
  profileAvatar: String
  profileAvatar_not: String
  profileAvatar_in: [String!]
  profileAvatar_not_in: [String!]
  profileAvatar_lt: String
  profileAvatar_lte: String
  profileAvatar_gt: String
  profileAvatar_gte: String
  profileAvatar_contains: String
  profileAvatar_not_contains: String
  profileAvatar_starts_with: String
  profileAvatar_not_starts_with: String
  profileAvatar_ends_with: String
  profileAvatar_not_ends_with: String
  profileJobTitle: String
  profileJobTitle_not: String
  profileJobTitle_in: [String!]
  profileJobTitle_not_in: [String!]
  profileJobTitle_lt: String
  profileJobTitle_lte: String
  profileJobTitle_gt: String
  profileJobTitle_gte: String
  profileJobTitle_contains: String
  profileJobTitle_not_contains: String
  profileJobTitle_starts_with: String
  profileJobTitle_not_starts_with: String
  profileJobTitle_ends_with: String
  profileJobTitle_not_ends_with: String
  profileBanner: String
  profileBanner_not: String
  profileBanner_in: [String!]
  profileBanner_not_in: [String!]
  profileBanner_lt: String
  profileBanner_lte: String
  profileBanner_gt: String
  profileBanner_gte: String
  profileBanner_contains: String
  profileBanner_not_contains: String
  profileBanner_starts_with: String
  profileBanner_not_starts_with: String
  profileBanner_ends_with: String
  profileBanner_not_ends_with: String
  profileType: ProfileType
  profileType_not: ProfileType
  profileType_in: [ProfileType!]
  profileType_not_in: [ProfileType!]
  serviceDescription: String
  serviceDescription_not: String
  serviceDescription_in: [String!]
  serviceDescription_not_in: [String!]
  serviceDescription_lt: String
  serviceDescription_lte: String
  serviceDescription_gt: String
  serviceDescription_gte: String
  serviceDescription_contains: String
  serviceDescription_not_contains: String
  serviceDescription_starts_with: String
  serviceDescription_not_starts_with: String
  serviceDescription_ends_with: String
  serviceDescription_not_ends_with: String
  inboxDescription: String
  inboxDescription_not: String
  inboxDescription_in: [String!]
  inboxDescription_not_in: [String!]
  inboxDescription_lt: String
  inboxDescription_lte: String
  inboxDescription_gt: String
  inboxDescription_gte: String
  inboxDescription_contains: String
  inboxDescription_not_contains: String
  inboxDescription_starts_with: String
  inboxDescription_not_starts_with: String
  inboxDescription_ends_with: String
  inboxDescription_not_ends_with: String
  AND: [AgentWhereInput!]
  OR: [AgentWhereInput!]
  NOT: [AgentWhereInput!]
}

input AgentWhereUniqueInput {
  id: ID
}

type AggregateAgent {
  count: Int!
}

type AggregateContentEncoding {
  count: Int!
}

type AggregateEntry {
  count: Int!
}

type AggregateGroup {
  count: Int!
}

type AggregateLocation {
  count: Int!
}

type AggregateMembership {
  count: Int!
}

type AggregateSession {
  count: Int!
}

type AggregateTag {
  count: Int!
}

type AggregateUser {
  count: Int!
}

type BatchPayload {
  count: Long!
}

type ContentEncoding {
  id: ID!
  type: EncodingType!
  maintainer: ID!
  createdBy: ID!
  createdAt: DateTime!
  updatedBy: ID
  updatedAt: DateTime
  name: String!
  charset: String!
  language: String
  data: String
}

type ContentEncodingConnection {
  pageInfo: PageInfo!
  edges: [ContentEncodingEdge]!
  aggregate: AggregateContentEncoding!
}

input ContentEncodingCreateInput {
  id: ID
  type: EncodingType!
  maintainer: ID!
  createdBy: ID!
  updatedBy: ID
  name: String!
  charset: String!
  language: String
  data: String
}

type ContentEncodingEdge {
  node: ContentEncoding!
  cursor: String!
}

enum ContentEncodingOrderByInput {
  id_ASC
  id_DESC
  type_ASC
  type_DESC
  maintainer_ASC
  maintainer_DESC
  createdBy_ASC
  createdBy_DESC
  createdAt_ASC
  createdAt_DESC
  updatedBy_ASC
  updatedBy_DESC
  updatedAt_ASC
  updatedAt_DESC
  name_ASC
  name_DESC
  charset_ASC
  charset_DESC
  language_ASC
  language_DESC
  data_ASC
  data_DESC
}

type ContentEncodingPreviousValues {
  id: ID!
  type: EncodingType!
  maintainer: ID!
  createdBy: ID!
  createdAt: DateTime!
  updatedBy: ID
  updatedAt: DateTime
  name: String!
  charset: String!
  language: String
  data: String
}

type ContentEncodingSubscriptionPayload {
  mutation: MutationType!
  node: ContentEncoding
  updatedFields: [String!]
  previousValues: ContentEncodingPreviousValues
}

input ContentEncodingSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ContentEncodingWhereInput
  AND: [ContentEncodingSubscriptionWhereInput!]
  OR: [ContentEncodingSubscriptionWhereInput!]
  NOT: [ContentEncodingSubscriptionWhereInput!]
}

input ContentEncodingUpdateInput {
  type: EncodingType
  maintainer: ID
  createdBy: ID
  updatedBy: ID
  name: String
  charset: String
  language: String
  data: String
}

input ContentEncodingUpdateManyMutationInput {
  type: EncodingType
  maintainer: ID
  createdBy: ID
  updatedBy: ID
  name: String
  charset: String
  language: String
  data: String
}

input ContentEncodingWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  type: EncodingType
  type_not: EncodingType
  type_in: [EncodingType!]
  type_not_in: [EncodingType!]
  maintainer: ID
  maintainer_not: ID
  maintainer_in: [ID!]
  maintainer_not_in: [ID!]
  maintainer_lt: ID
  maintainer_lte: ID
  maintainer_gt: ID
  maintainer_gte: ID
  maintainer_contains: ID
  maintainer_not_contains: ID
  maintainer_starts_with: ID
  maintainer_not_starts_with: ID
  maintainer_ends_with: ID
  maintainer_not_ends_with: ID
  createdBy: ID
  createdBy_not: ID
  createdBy_in: [ID!]
  createdBy_not_in: [ID!]
  createdBy_lt: ID
  createdBy_lte: ID
  createdBy_gt: ID
  createdBy_gte: ID
  createdBy_contains: ID
  createdBy_not_contains: ID
  createdBy_starts_with: ID
  createdBy_not_starts_with: ID
  createdBy_ends_with: ID
  createdBy_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedBy: ID
  updatedBy_not: ID
  updatedBy_in: [ID!]
  updatedBy_not_in: [ID!]
  updatedBy_lt: ID
  updatedBy_lte: ID
  updatedBy_gt: ID
  updatedBy_gte: ID
  updatedBy_contains: ID
  updatedBy_not_contains: ID
  updatedBy_starts_with: ID
  updatedBy_not_starts_with: ID
  updatedBy_ends_with: ID
  updatedBy_not_ends_with: ID
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  charset: String
  charset_not: String
  charset_in: [String!]
  charset_not_in: [String!]
  charset_lt: String
  charset_lte: String
  charset_gt: String
  charset_gte: String
  charset_contains: String
  charset_not_contains: String
  charset_starts_with: String
  charset_not_starts_with: String
  charset_ends_with: String
  charset_not_ends_with: String
  language: String
  language_not: String
  language_in: [String!]
  language_not_in: [String!]
  language_lt: String
  language_lte: String
  language_gt: String
  language_gte: String
  language_contains: String
  language_not_contains: String
  language_starts_with: String
  language_not_starts_with: String
  language_ends_with: String
  language_not_ends_with: String
  data: String
  data_not: String
  data_in: [String!]
  data_not_in: [String!]
  data_lt: String
  data_lte: String
  data_gt: String
  data_gte: String
  data_contains: String
  data_not_contains: String
  data_starts_with: String
  data_not_starts_with: String
  data_ends_with: String
  data_not_ends_with: String
  AND: [ContentEncodingWhereInput!]
  OR: [ContentEncodingWhereInput!]
  NOT: [ContentEncodingWhereInput!]
}

input ContentEncodingWhereUniqueInput {
  id: ID
}

scalar DateTime

enum EncodingType {
  Custom
  Base64
  Microformat
  TableSchema
  JsonSchema
  XmlSchema
  GqlSchema
  RdfSchema
  Owl
}

type Entry {
  id: ID!
  type: EntryType!
  owner: ID!
  createdBy: ID!
  createdAt: DateTime!
  updatedBy: ID
  updatedAt: DateTime
  name: String
  content: Json
  contentEncoding: ID
  tags(where: TagWhereInput, orderBy: TagOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Tag!]
}

type EntryConnection {
  pageInfo: PageInfo!
  edges: [EntryEdge]!
  aggregate: AggregateEntry!
}

input EntryCreateInput {
  id: ID
  type: EntryType!
  owner: ID!
  createdBy: ID!
  updatedBy: ID
  name: String
  content: Json
  contentEncoding: ID
  tags: TagCreateManyInput
}

input EntryCreateManyInput {
  create: [EntryCreateInput!]
  connect: [EntryWhereUniqueInput!]
}

type EntryEdge {
  node: Entry!
  cursor: String!
}

enum EntryOrderByInput {
  id_ASC
  id_DESC
  type_ASC
  type_DESC
  owner_ASC
  owner_DESC
  createdBy_ASC
  createdBy_DESC
  createdAt_ASC
  createdAt_DESC
  updatedBy_ASC
  updatedBy_DESC
  updatedAt_ASC
  updatedAt_DESC
  name_ASC
  name_DESC
  content_ASC
  content_DESC
  contentEncoding_ASC
  contentEncoding_DESC
}

type EntryPreviousValues {
  id: ID!
  type: EntryType!
  owner: ID!
  createdBy: ID!
  createdAt: DateTime!
  updatedBy: ID
  updatedAt: DateTime
  name: String
  content: Json
  contentEncoding: ID
}

input EntryScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  type: EntryType
  type_not: EntryType
  type_in: [EntryType!]
  type_not_in: [EntryType!]
  owner: ID
  owner_not: ID
  owner_in: [ID!]
  owner_not_in: [ID!]
  owner_lt: ID
  owner_lte: ID
  owner_gt: ID
  owner_gte: ID
  owner_contains: ID
  owner_not_contains: ID
  owner_starts_with: ID
  owner_not_starts_with: ID
  owner_ends_with: ID
  owner_not_ends_with: ID
  createdBy: ID
  createdBy_not: ID
  createdBy_in: [ID!]
  createdBy_not_in: [ID!]
  createdBy_lt: ID
  createdBy_lte: ID
  createdBy_gt: ID
  createdBy_gte: ID
  createdBy_contains: ID
  createdBy_not_contains: ID
  createdBy_starts_with: ID
  createdBy_not_starts_with: ID
  createdBy_ends_with: ID
  createdBy_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedBy: ID
  updatedBy_not: ID
  updatedBy_in: [ID!]
  updatedBy_not_in: [ID!]
  updatedBy_lt: ID
  updatedBy_lte: ID
  updatedBy_gt: ID
  updatedBy_gte: ID
  updatedBy_contains: ID
  updatedBy_not_contains: ID
  updatedBy_starts_with: ID
  updatedBy_not_starts_with: ID
  updatedBy_ends_with: ID
  updatedBy_not_ends_with: ID
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  contentEncoding: ID
  contentEncoding_not: ID
  contentEncoding_in: [ID!]
  contentEncoding_not_in: [ID!]
  contentEncoding_lt: ID
  contentEncoding_lte: ID
  contentEncoding_gt: ID
  contentEncoding_gte: ID
  contentEncoding_contains: ID
  contentEncoding_not_contains: ID
  contentEncoding_starts_with: ID
  contentEncoding_not_starts_with: ID
  contentEncoding_ends_with: ID
  contentEncoding_not_ends_with: ID
  AND: [EntryScalarWhereInput!]
  OR: [EntryScalarWhereInput!]
  NOT: [EntryScalarWhereInput!]
}

type EntrySubscriptionPayload {
  mutation: MutationType!
  node: Entry
  updatedFields: [String!]
  previousValues: EntryPreviousValues
}

input EntrySubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: EntryWhereInput
  AND: [EntrySubscriptionWhereInput!]
  OR: [EntrySubscriptionWhereInput!]
  NOT: [EntrySubscriptionWhereInput!]
}

enum EntryType {
  Empty
  Json
  Table
  Document
  Picture
  File
  Thing
}

input EntryUpdateDataInput {
  type: EntryType
  owner: ID
  createdBy: ID
  updatedBy: ID
  name: String
  content: Json
  contentEncoding: ID
  tags: TagUpdateManyInput
}

input EntryUpdateInput {
  type: EntryType
  owner: ID
  createdBy: ID
  updatedBy: ID
  name: String
  content: Json
  contentEncoding: ID
  tags: TagUpdateManyInput
}

input EntryUpdateManyDataInput {
  type: EntryType
  owner: ID
  createdBy: ID
  updatedBy: ID
  name: String
  content: Json
  contentEncoding: ID
}

input EntryUpdateManyInput {
  create: [EntryCreateInput!]
  update: [EntryUpdateWithWhereUniqueNestedInput!]
  upsert: [EntryUpsertWithWhereUniqueNestedInput!]
  delete: [EntryWhereUniqueInput!]
  connect: [EntryWhereUniqueInput!]
  set: [EntryWhereUniqueInput!]
  disconnect: [EntryWhereUniqueInput!]
  deleteMany: [EntryScalarWhereInput!]
  updateMany: [EntryUpdateManyWithWhereNestedInput!]
}

input EntryUpdateManyMutationInput {
  type: EntryType
  owner: ID
  createdBy: ID
  updatedBy: ID
  name: String
  content: Json
  contentEncoding: ID
}

input EntryUpdateManyWithWhereNestedInput {
  where: EntryScalarWhereInput!
  data: EntryUpdateManyDataInput!
}

input EntryUpdateWithWhereUniqueNestedInput {
  where: EntryWhereUniqueInput!
  data: EntryUpdateDataInput!
}

input EntryUpsertWithWhereUniqueNestedInput {
  where: EntryWhereUniqueInput!
  update: EntryUpdateDataInput!
  create: EntryCreateInput!
}

input EntryWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  type: EntryType
  type_not: EntryType
  type_in: [EntryType!]
  type_not_in: [EntryType!]
  owner: ID
  owner_not: ID
  owner_in: [ID!]
  owner_not_in: [ID!]
  owner_lt: ID
  owner_lte: ID
  owner_gt: ID
  owner_gte: ID
  owner_contains: ID
  owner_not_contains: ID
  owner_starts_with: ID
  owner_not_starts_with: ID
  owner_ends_with: ID
  owner_not_ends_with: ID
  createdBy: ID
  createdBy_not: ID
  createdBy_in: [ID!]
  createdBy_not_in: [ID!]
  createdBy_lt: ID
  createdBy_lte: ID
  createdBy_gt: ID
  createdBy_gte: ID
  createdBy_contains: ID
  createdBy_not_contains: ID
  createdBy_starts_with: ID
  createdBy_not_starts_with: ID
  createdBy_ends_with: ID
  createdBy_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedBy: ID
  updatedBy_not: ID
  updatedBy_in: [ID!]
  updatedBy_not_in: [ID!]
  updatedBy_lt: ID
  updatedBy_lte: ID
  updatedBy_gt: ID
  updatedBy_gte: ID
  updatedBy_contains: ID
  updatedBy_not_contains: ID
  updatedBy_starts_with: ID
  updatedBy_not_starts_with: ID
  updatedBy_ends_with: ID
  updatedBy_not_ends_with: ID
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  contentEncoding: ID
  contentEncoding_not: ID
  contentEncoding_in: [ID!]
  contentEncoding_not_in: [ID!]
  contentEncoding_lt: ID
  contentEncoding_lte: ID
  contentEncoding_gt: ID
  contentEncoding_gte: ID
  contentEncoding_contains: ID
  contentEncoding_not_contains: ID
  contentEncoding_starts_with: ID
  contentEncoding_not_starts_with: ID
  contentEncoding_ends_with: ID
  contentEncoding_not_ends_with: ID
  tags_every: TagWhereInput
  tags_some: TagWhereInput
  tags_none: TagWhereInput
  AND: [EntryWhereInput!]
  OR: [EntryWhereInput!]
  NOT: [EntryWhereInput!]
}

input EntryWhereUniqueInput {
  id: ID
}

type Group {
  id: ID!
  type: GroupType!
  owner: ID!
  createdBy: ID!
  createdAt: DateTime!
  updatedBy: ID
  updatedAt: DateTime
  isPublic: Boolean!
  memberships(where: MembershipWhereInput, orderBy: MembershipOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Membership!]
  name: String!
  title: String
  description: String
  logo: String!
  banner: String
  entries(where: EntryWhereInput, orderBy: EntryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Entry!]
  inbox: ID
  tags(where: TagWhereInput, orderBy: TagOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Tag!]
}

type GroupConnection {
  pageInfo: PageInfo!
  edges: [GroupEdge]!
  aggregate: AggregateGroup!
}

input GroupCreateInput {
  id: ID
  type: GroupType!
  owner: ID!
  createdBy: ID!
  updatedBy: ID
  isPublic: Boolean!
  memberships: MembershipCreateManyInput
  name: String!
  title: String
  description: String
  logo: String!
  banner: String
  entries: EntryCreateManyInput
  inbox: ID
  tags: TagCreateManyInput
}

type GroupEdge {
  node: Group!
  cursor: String!
}

enum GroupOrderByInput {
  id_ASC
  id_DESC
  type_ASC
  type_DESC
  owner_ASC
  owner_DESC
  createdBy_ASC
  createdBy_DESC
  createdAt_ASC
  createdAt_DESC
  updatedBy_ASC
  updatedBy_DESC
  updatedAt_ASC
  updatedAt_DESC
  isPublic_ASC
  isPublic_DESC
  name_ASC
  name_DESC
  title_ASC
  title_DESC
  description_ASC
  description_DESC
  logo_ASC
  logo_DESC
  banner_ASC
  banner_DESC
  inbox_ASC
  inbox_DESC
}

type GroupPreviousValues {
  id: ID!
  type: GroupType!
  owner: ID!
  createdBy: ID!
  createdAt: DateTime!
  updatedBy: ID
  updatedAt: DateTime
  isPublic: Boolean!
  name: String!
  title: String
  description: String
  logo: String!
  banner: String
  inbox: ID
}

type GroupSubscriptionPayload {
  mutation: MutationType!
  node: Group
  updatedFields: [String!]
  previousValues: GroupPreviousValues
}

input GroupSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: GroupWhereInput
  AND: [GroupSubscriptionWhereInput!]
  OR: [GroupSubscriptionWhereInput!]
  NOT: [GroupSubscriptionWhereInput!]
}

enum GroupType {
  Stash
  Channel
  Room
}

input GroupUpdateInput {
  type: GroupType
  owner: ID
  createdBy: ID
  updatedBy: ID
  isPublic: Boolean
  memberships: MembershipUpdateManyInput
  name: String
  title: String
  description: String
  logo: String
  banner: String
  entries: EntryUpdateManyInput
  inbox: ID
  tags: TagUpdateManyInput
}

input GroupUpdateManyMutationInput {
  type: GroupType
  owner: ID
  createdBy: ID
  updatedBy: ID
  isPublic: Boolean
  name: String
  title: String
  description: String
  logo: String
  banner: String
  inbox: ID
}

input GroupWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  type: GroupType
  type_not: GroupType
  type_in: [GroupType!]
  type_not_in: [GroupType!]
  owner: ID
  owner_not: ID
  owner_in: [ID!]
  owner_not_in: [ID!]
  owner_lt: ID
  owner_lte: ID
  owner_gt: ID
  owner_gte: ID
  owner_contains: ID
  owner_not_contains: ID
  owner_starts_with: ID
  owner_not_starts_with: ID
  owner_ends_with: ID
  owner_not_ends_with: ID
  createdBy: ID
  createdBy_not: ID
  createdBy_in: [ID!]
  createdBy_not_in: [ID!]
  createdBy_lt: ID
  createdBy_lte: ID
  createdBy_gt: ID
  createdBy_gte: ID
  createdBy_contains: ID
  createdBy_not_contains: ID
  createdBy_starts_with: ID
  createdBy_not_starts_with: ID
  createdBy_ends_with: ID
  createdBy_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedBy: ID
  updatedBy_not: ID
  updatedBy_in: [ID!]
  updatedBy_not_in: [ID!]
  updatedBy_lt: ID
  updatedBy_lte: ID
  updatedBy_gt: ID
  updatedBy_gte: ID
  updatedBy_contains: ID
  updatedBy_not_contains: ID
  updatedBy_starts_with: ID
  updatedBy_not_starts_with: ID
  updatedBy_ends_with: ID
  updatedBy_not_ends_with: ID
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  isPublic: Boolean
  isPublic_not: Boolean
  memberships_every: MembershipWhereInput
  memberships_some: MembershipWhereInput
  memberships_none: MembershipWhereInput
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  logo: String
  logo_not: String
  logo_in: [String!]
  logo_not_in: [String!]
  logo_lt: String
  logo_lte: String
  logo_gt: String
  logo_gte: String
  logo_contains: String
  logo_not_contains: String
  logo_starts_with: String
  logo_not_starts_with: String
  logo_ends_with: String
  logo_not_ends_with: String
  banner: String
  banner_not: String
  banner_in: [String!]
  banner_not_in: [String!]
  banner_lt: String
  banner_lte: String
  banner_gt: String
  banner_gte: String
  banner_contains: String
  banner_not_contains: String
  banner_starts_with: String
  banner_not_starts_with: String
  banner_ends_with: String
  banner_not_ends_with: String
  entries_every: EntryWhereInput
  entries_some: EntryWhereInput
  entries_none: EntryWhereInput
  inbox: ID
  inbox_not: ID
  inbox_in: [ID!]
  inbox_not_in: [ID!]
  inbox_lt: ID
  inbox_lte: ID
  inbox_gt: ID
  inbox_gte: ID
  inbox_contains: ID
  inbox_not_contains: ID
  inbox_starts_with: ID
  inbox_not_starts_with: ID
  inbox_ends_with: ID
  inbox_not_ends_with: ID
  tags_every: TagWhereInput
  tags_some: TagWhereInput
  tags_none: TagWhereInput
  AND: [GroupWhereInput!]
  OR: [GroupWhereInput!]
  NOT: [GroupWhereInput!]
}

input GroupWhereUniqueInput {
  id: ID
}

scalar Json

type Location {
  id: ID!
  type: LocationType!
  owner: ID!
  createdBy: ID!
  createdAt: DateTime!
  updatedBy: ID
  updatedAt: DateTime
  name: String
  osmNodeId: String
  addressLine1: String
  addressLine2: String
  addressCity: String
  addressZipCode: String
  addressCountry: String
  geoPointLatitude: Float
  geoPointLongitude: Float
  geoPointRadiusMeter: Float
  tags(where: TagWhereInput, orderBy: TagOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Tag!]
}

type LocationConnection {
  pageInfo: PageInfo!
  edges: [LocationEdge]!
  aggregate: AggregateLocation!
}

input LocationCreateInput {
  id: ID
  type: LocationType!
  owner: ID!
  createdBy: ID!
  updatedBy: ID
  name: String
  osmNodeId: String
  addressLine1: String
  addressLine2: String
  addressCity: String
  addressZipCode: String
  addressCountry: String
  geoPointLatitude: Float
  geoPointLongitude: Float
  geoPointRadiusMeter: Float
  tags: TagCreateManyInput
}

input LocationCreateOneInput {
  create: LocationCreateInput
  connect: LocationWhereUniqueInput
}

type LocationEdge {
  node: Location!
  cursor: String!
}

enum LocationOrderByInput {
  id_ASC
  id_DESC
  type_ASC
  type_DESC
  owner_ASC
  owner_DESC
  createdBy_ASC
  createdBy_DESC
  createdAt_ASC
  createdAt_DESC
  updatedBy_ASC
  updatedBy_DESC
  updatedAt_ASC
  updatedAt_DESC
  name_ASC
  name_DESC
  osmNodeId_ASC
  osmNodeId_DESC
  addressLine1_ASC
  addressLine1_DESC
  addressLine2_ASC
  addressLine2_DESC
  addressCity_ASC
  addressCity_DESC
  addressZipCode_ASC
  addressZipCode_DESC
  addressCountry_ASC
  addressCountry_DESC
  geoPointLatitude_ASC
  geoPointLatitude_DESC
  geoPointLongitude_ASC
  geoPointLongitude_DESC
  geoPointRadiusMeter_ASC
  geoPointRadiusMeter_DESC
}

type LocationPreviousValues {
  id: ID!
  type: LocationType!
  owner: ID!
  createdBy: ID!
  createdAt: DateTime!
  updatedBy: ID
  updatedAt: DateTime
  name: String
  osmNodeId: String
  addressLine1: String
  addressLine2: String
  addressCity: String
  addressZipCode: String
  addressCountry: String
  geoPointLatitude: Float
  geoPointLongitude: Float
  geoPointRadiusMeter: Float
}

type LocationSubscriptionPayload {
  mutation: MutationType!
  node: Location
  updatedFields: [String!]
  previousValues: LocationPreviousValues
}

input LocationSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: LocationWhereInput
  AND: [LocationSubscriptionWhereInput!]
  OR: [LocationSubscriptionWhereInput!]
  NOT: [LocationSubscriptionWhereInput!]
}

enum LocationType {
  OpenStreetMap
  Address
  GeoPoint
}

input LocationUpdateDataInput {
  type: LocationType
  owner: ID
  createdBy: ID
  updatedBy: ID
  name: String
  osmNodeId: String
  addressLine1: String
  addressLine2: String
  addressCity: String
  addressZipCode: String
  addressCountry: String
  geoPointLatitude: Float
  geoPointLongitude: Float
  geoPointRadiusMeter: Float
  tags: TagUpdateManyInput
}

input LocationUpdateInput {
  type: LocationType
  owner: ID
  createdBy: ID
  updatedBy: ID
  name: String
  osmNodeId: String
  addressLine1: String
  addressLine2: String
  addressCity: String
  addressZipCode: String
  addressCountry: String
  geoPointLatitude: Float
  geoPointLongitude: Float
  geoPointRadiusMeter: Float
  tags: TagUpdateManyInput
}

input LocationUpdateManyMutationInput {
  type: LocationType
  owner: ID
  createdBy: ID
  updatedBy: ID
  name: String
  osmNodeId: String
  addressLine1: String
  addressLine2: String
  addressCity: String
  addressZipCode: String
  addressCountry: String
  geoPointLatitude: Float
  geoPointLongitude: Float
  geoPointRadiusMeter: Float
}

input LocationUpdateOneInput {
  create: LocationCreateInput
  update: LocationUpdateDataInput
  upsert: LocationUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: LocationWhereUniqueInput
}

input LocationUpsertNestedInput {
  update: LocationUpdateDataInput!
  create: LocationCreateInput!
}

input LocationWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  type: LocationType
  type_not: LocationType
  type_in: [LocationType!]
  type_not_in: [LocationType!]
  owner: ID
  owner_not: ID
  owner_in: [ID!]
  owner_not_in: [ID!]
  owner_lt: ID
  owner_lte: ID
  owner_gt: ID
  owner_gte: ID
  owner_contains: ID
  owner_not_contains: ID
  owner_starts_with: ID
  owner_not_starts_with: ID
  owner_ends_with: ID
  owner_not_ends_with: ID
  createdBy: ID
  createdBy_not: ID
  createdBy_in: [ID!]
  createdBy_not_in: [ID!]
  createdBy_lt: ID
  createdBy_lte: ID
  createdBy_gt: ID
  createdBy_gte: ID
  createdBy_contains: ID
  createdBy_not_contains: ID
  createdBy_starts_with: ID
  createdBy_not_starts_with: ID
  createdBy_ends_with: ID
  createdBy_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedBy: ID
  updatedBy_not: ID
  updatedBy_in: [ID!]
  updatedBy_not_in: [ID!]
  updatedBy_lt: ID
  updatedBy_lte: ID
  updatedBy_gt: ID
  updatedBy_gte: ID
  updatedBy_contains: ID
  updatedBy_not_contains: ID
  updatedBy_starts_with: ID
  updatedBy_not_starts_with: ID
  updatedBy_ends_with: ID
  updatedBy_not_ends_with: ID
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  osmNodeId: String
  osmNodeId_not: String
  osmNodeId_in: [String!]
  osmNodeId_not_in: [String!]
  osmNodeId_lt: String
  osmNodeId_lte: String
  osmNodeId_gt: String
  osmNodeId_gte: String
  osmNodeId_contains: String
  osmNodeId_not_contains: String
  osmNodeId_starts_with: String
  osmNodeId_not_starts_with: String
  osmNodeId_ends_with: String
  osmNodeId_not_ends_with: String
  addressLine1: String
  addressLine1_not: String
  addressLine1_in: [String!]
  addressLine1_not_in: [String!]
  addressLine1_lt: String
  addressLine1_lte: String
  addressLine1_gt: String
  addressLine1_gte: String
  addressLine1_contains: String
  addressLine1_not_contains: String
  addressLine1_starts_with: String
  addressLine1_not_starts_with: String
  addressLine1_ends_with: String
  addressLine1_not_ends_with: String
  addressLine2: String
  addressLine2_not: String
  addressLine2_in: [String!]
  addressLine2_not_in: [String!]
  addressLine2_lt: String
  addressLine2_lte: String
  addressLine2_gt: String
  addressLine2_gte: String
  addressLine2_contains: String
  addressLine2_not_contains: String
  addressLine2_starts_with: String
  addressLine2_not_starts_with: String
  addressLine2_ends_with: String
  addressLine2_not_ends_with: String
  addressCity: String
  addressCity_not: String
  addressCity_in: [String!]
  addressCity_not_in: [String!]
  addressCity_lt: String
  addressCity_lte: String
  addressCity_gt: String
  addressCity_gte: String
  addressCity_contains: String
  addressCity_not_contains: String
  addressCity_starts_with: String
  addressCity_not_starts_with: String
  addressCity_ends_with: String
  addressCity_not_ends_with: String
  addressZipCode: String
  addressZipCode_not: String
  addressZipCode_in: [String!]
  addressZipCode_not_in: [String!]
  addressZipCode_lt: String
  addressZipCode_lte: String
  addressZipCode_gt: String
  addressZipCode_gte: String
  addressZipCode_contains: String
  addressZipCode_not_contains: String
  addressZipCode_starts_with: String
  addressZipCode_not_starts_with: String
  addressZipCode_ends_with: String
  addressZipCode_not_ends_with: String
  addressCountry: String
  addressCountry_not: String
  addressCountry_in: [String!]
  addressCountry_not_in: [String!]
  addressCountry_lt: String
  addressCountry_lte: String
  addressCountry_gt: String
  addressCountry_gte: String
  addressCountry_contains: String
  addressCountry_not_contains: String
  addressCountry_starts_with: String
  addressCountry_not_starts_with: String
  addressCountry_ends_with: String
  addressCountry_not_ends_with: String
  geoPointLatitude: Float
  geoPointLatitude_not: Float
  geoPointLatitude_in: [Float!]
  geoPointLatitude_not_in: [Float!]
  geoPointLatitude_lt: Float
  geoPointLatitude_lte: Float
  geoPointLatitude_gt: Float
  geoPointLatitude_gte: Float
  geoPointLongitude: Float
  geoPointLongitude_not: Float
  geoPointLongitude_in: [Float!]
  geoPointLongitude_not_in: [Float!]
  geoPointLongitude_lt: Float
  geoPointLongitude_lte: Float
  geoPointLongitude_gt: Float
  geoPointLongitude_gte: Float
  geoPointRadiusMeter: Float
  geoPointRadiusMeter_not: Float
  geoPointRadiusMeter_in: [Float!]
  geoPointRadiusMeter_not_in: [Float!]
  geoPointRadiusMeter_lt: Float
  geoPointRadiusMeter_lte: Float
  geoPointRadiusMeter_gt: Float
  geoPointRadiusMeter_gte: Float
  tags_every: TagWhereInput
  tags_some: TagWhereInput
  tags_none: TagWhereInput
  AND: [LocationWhereInput!]
  OR: [LocationWhereInput!]
  NOT: [LocationWhereInput!]
}

input LocationWhereUniqueInput {
  id: ID
}

scalar Long

type Membership {
  id: ID!
  type: MembershipType!
  createdBy: ID!
  createdAt: DateTime!
  updatedBy: ID
  updatedAt: DateTime
  member: Agent!
  showHistory: Boolean!
}

type MembershipConnection {
  pageInfo: PageInfo!
  edges: [MembershipEdge]!
  aggregate: AggregateMembership!
}

input MembershipCreateInput {
  id: ID
  type: MembershipType!
  createdBy: ID!
  updatedBy: ID
  member: AgentCreateOneInput!
  showHistory: Boolean!
}

input MembershipCreateManyInput {
  create: [MembershipCreateInput!]
  connect: [MembershipWhereUniqueInput!]
}

type MembershipEdge {
  node: Membership!
  cursor: String!
}

enum MembershipOrderByInput {
  id_ASC
  id_DESC
  type_ASC
  type_DESC
  createdBy_ASC
  createdBy_DESC
  createdAt_ASC
  createdAt_DESC
  updatedBy_ASC
  updatedBy_DESC
  updatedAt_ASC
  updatedAt_DESC
  showHistory_ASC
  showHistory_DESC
}

type MembershipPreviousValues {
  id: ID!
  type: MembershipType!
  createdBy: ID!
  createdAt: DateTime!
  updatedBy: ID
  updatedAt: DateTime
  showHistory: Boolean!
}

input MembershipScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  type: MembershipType
  type_not: MembershipType
  type_in: [MembershipType!]
  type_not_in: [MembershipType!]
  createdBy: ID
  createdBy_not: ID
  createdBy_in: [ID!]
  createdBy_not_in: [ID!]
  createdBy_lt: ID
  createdBy_lte: ID
  createdBy_gt: ID
  createdBy_gte: ID
  createdBy_contains: ID
  createdBy_not_contains: ID
  createdBy_starts_with: ID
  createdBy_not_starts_with: ID
  createdBy_ends_with: ID
  createdBy_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedBy: ID
  updatedBy_not: ID
  updatedBy_in: [ID!]
  updatedBy_not_in: [ID!]
  updatedBy_lt: ID
  updatedBy_lte: ID
  updatedBy_gt: ID
  updatedBy_gte: ID
  updatedBy_contains: ID
  updatedBy_not_contains: ID
  updatedBy_starts_with: ID
  updatedBy_not_starts_with: ID
  updatedBy_ends_with: ID
  updatedBy_not_ends_with: ID
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  showHistory: Boolean
  showHistory_not: Boolean
  AND: [MembershipScalarWhereInput!]
  OR: [MembershipScalarWhereInput!]
  NOT: [MembershipScalarWhereInput!]
}

type MembershipSubscriptionPayload {
  mutation: MutationType!
  node: Membership
  updatedFields: [String!]
  previousValues: MembershipPreviousValues
}

input MembershipSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: MembershipWhereInput
  AND: [MembershipSubscriptionWhereInput!]
  OR: [MembershipSubscriptionWhereInput!]
  NOT: [MembershipSubscriptionWhereInput!]
}

enum MembershipType {
  Invite
  Single
  Multi
}

input MembershipUpdateDataInput {
  type: MembershipType
  createdBy: ID
  updatedBy: ID
  member: AgentUpdateOneRequiredInput
  showHistory: Boolean
}

input MembershipUpdateInput {
  type: MembershipType
  createdBy: ID
  updatedBy: ID
  member: AgentUpdateOneRequiredInput
  showHistory: Boolean
}

input MembershipUpdateManyDataInput {
  type: MembershipType
  createdBy: ID
  updatedBy: ID
  showHistory: Boolean
}

input MembershipUpdateManyInput {
  create: [MembershipCreateInput!]
  update: [MembershipUpdateWithWhereUniqueNestedInput!]
  upsert: [MembershipUpsertWithWhereUniqueNestedInput!]
  delete: [MembershipWhereUniqueInput!]
  connect: [MembershipWhereUniqueInput!]
  set: [MembershipWhereUniqueInput!]
  disconnect: [MembershipWhereUniqueInput!]
  deleteMany: [MembershipScalarWhereInput!]
  updateMany: [MembershipUpdateManyWithWhereNestedInput!]
}

input MembershipUpdateManyMutationInput {
  type: MembershipType
  createdBy: ID
  updatedBy: ID
  showHistory: Boolean
}

input MembershipUpdateManyWithWhereNestedInput {
  where: MembershipScalarWhereInput!
  data: MembershipUpdateManyDataInput!
}

input MembershipUpdateWithWhereUniqueNestedInput {
  where: MembershipWhereUniqueInput!
  data: MembershipUpdateDataInput!
}

input MembershipUpsertWithWhereUniqueNestedInput {
  where: MembershipWhereUniqueInput!
  update: MembershipUpdateDataInput!
  create: MembershipCreateInput!
}

input MembershipWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  type: MembershipType
  type_not: MembershipType
  type_in: [MembershipType!]
  type_not_in: [MembershipType!]
  createdBy: ID
  createdBy_not: ID
  createdBy_in: [ID!]
  createdBy_not_in: [ID!]
  createdBy_lt: ID
  createdBy_lte: ID
  createdBy_gt: ID
  createdBy_gte: ID
  createdBy_contains: ID
  createdBy_not_contains: ID
  createdBy_starts_with: ID
  createdBy_not_starts_with: ID
  createdBy_ends_with: ID
  createdBy_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedBy: ID
  updatedBy_not: ID
  updatedBy_in: [ID!]
  updatedBy_not_in: [ID!]
  updatedBy_lt: ID
  updatedBy_lte: ID
  updatedBy_gt: ID
  updatedBy_gte: ID
  updatedBy_contains: ID
  updatedBy_not_contains: ID
  updatedBy_starts_with: ID
  updatedBy_not_starts_with: ID
  updatedBy_ends_with: ID
  updatedBy_not_ends_with: ID
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  member: AgentWhereInput
  showHistory: Boolean
  showHistory_not: Boolean
  AND: [MembershipWhereInput!]
  OR: [MembershipWhereInput!]
  NOT: [MembershipWhereInput!]
}

input MembershipWhereUniqueInput {
  id: ID
}

type Mutation {
  createAgent(data: AgentCreateInput!): Agent!
  updateAgent(data: AgentUpdateInput!, where: AgentWhereUniqueInput!): Agent
  updateManyAgents(data: AgentUpdateManyMutationInput!, where: AgentWhereInput): BatchPayload!
  upsertAgent(where: AgentWhereUniqueInput!, create: AgentCreateInput!, update: AgentUpdateInput!): Agent!
  deleteAgent(where: AgentWhereUniqueInput!): Agent
  deleteManyAgents(where: AgentWhereInput): BatchPayload!
  createContentEncoding(data: ContentEncodingCreateInput!): ContentEncoding!
  updateContentEncoding(data: ContentEncodingUpdateInput!, where: ContentEncodingWhereUniqueInput!): ContentEncoding
  updateManyContentEncodings(data: ContentEncodingUpdateManyMutationInput!, where: ContentEncodingWhereInput): BatchPayload!
  upsertContentEncoding(where: ContentEncodingWhereUniqueInput!, create: ContentEncodingCreateInput!, update: ContentEncodingUpdateInput!): ContentEncoding!
  deleteContentEncoding(where: ContentEncodingWhereUniqueInput!): ContentEncoding
  deleteManyContentEncodings(where: ContentEncodingWhereInput): BatchPayload!
  createEntry(data: EntryCreateInput!): Entry!
  updateEntry(data: EntryUpdateInput!, where: EntryWhereUniqueInput!): Entry
  updateManyEntries(data: EntryUpdateManyMutationInput!, where: EntryWhereInput): BatchPayload!
  upsertEntry(where: EntryWhereUniqueInput!, create: EntryCreateInput!, update: EntryUpdateInput!): Entry!
  deleteEntry(where: EntryWhereUniqueInput!): Entry
  deleteManyEntries(where: EntryWhereInput): BatchPayload!
  createGroup(data: GroupCreateInput!): Group!
  updateGroup(data: GroupUpdateInput!, where: GroupWhereUniqueInput!): Group
  updateManyGroups(data: GroupUpdateManyMutationInput!, where: GroupWhereInput): BatchPayload!
  upsertGroup(where: GroupWhereUniqueInput!, create: GroupCreateInput!, update: GroupUpdateInput!): Group!
  deleteGroup(where: GroupWhereUniqueInput!): Group
  deleteManyGroups(where: GroupWhereInput): BatchPayload!
  createLocation(data: LocationCreateInput!): Location!
  updateLocation(data: LocationUpdateInput!, where: LocationWhereUniqueInput!): Location
  updateManyLocations(data: LocationUpdateManyMutationInput!, where: LocationWhereInput): BatchPayload!
  upsertLocation(where: LocationWhereUniqueInput!, create: LocationCreateInput!, update: LocationUpdateInput!): Location!
  deleteLocation(where: LocationWhereUniqueInput!): Location
  deleteManyLocations(where: LocationWhereInput): BatchPayload!
  createMembership(data: MembershipCreateInput!): Membership!
  updateMembership(data: MembershipUpdateInput!, where: MembershipWhereUniqueInput!): Membership
  updateManyMemberships(data: MembershipUpdateManyMutationInput!, where: MembershipWhereInput): BatchPayload!
  upsertMembership(where: MembershipWhereUniqueInput!, create: MembershipCreateInput!, update: MembershipUpdateInput!): Membership!
  deleteMembership(where: MembershipWhereUniqueInput!): Membership
  deleteManyMemberships(where: MembershipWhereInput): BatchPayload!
  createSession(data: SessionCreateInput!): Session!
  updateSession(data: SessionUpdateInput!, where: SessionWhereUniqueInput!): Session
  updateManySessions(data: SessionUpdateManyMutationInput!, where: SessionWhereInput): BatchPayload!
  upsertSession(where: SessionWhereUniqueInput!, create: SessionCreateInput!, update: SessionUpdateInput!): Session!
  deleteSession(where: SessionWhereUniqueInput!): Session
  deleteManySessions(where: SessionWhereInput): BatchPayload!
  createTag(data: TagCreateInput!): Tag!
  updateTag(data: TagUpdateInput!, where: TagWhereUniqueInput!): Tag
  updateManyTags(data: TagUpdateManyMutationInput!, where: TagWhereInput): BatchPayload!
  upsertTag(where: TagWhereUniqueInput!, create: TagCreateInput!, update: TagUpdateInput!): Tag!
  deleteTag(where: TagWhereUniqueInput!): Tag
  deleteManyTags(where: TagWhereInput): BatchPayload!
  createUser(data: UserCreateInput!): User!
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  updateManyUsers(data: UserUpdateManyMutationInput!, where: UserWhereInput): BatchPayload!
  upsertUser(where: UserWhereUniqueInput!, create: UserCreateInput!, update: UserUpdateInput!): User!
  deleteUser(where: UserWhereUniqueInput!): User
  deleteManyUsers(where: UserWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

enum ProfileType {
  Business
  Private
  Anonymous
}

type Query {
  agent(where: AgentWhereUniqueInput!): Agent
  agents(where: AgentWhereInput, orderBy: AgentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Agent]!
  agentsConnection(where: AgentWhereInput, orderBy: AgentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): AgentConnection!
  contentEncoding(where: ContentEncodingWhereUniqueInput!): ContentEncoding
  contentEncodings(where: ContentEncodingWhereInput, orderBy: ContentEncodingOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ContentEncoding]!
  contentEncodingsConnection(where: ContentEncodingWhereInput, orderBy: ContentEncodingOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ContentEncodingConnection!
  entry(where: EntryWhereUniqueInput!): Entry
  entries(where: EntryWhereInput, orderBy: EntryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Entry]!
  entriesConnection(where: EntryWhereInput, orderBy: EntryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): EntryConnection!
  group(where: GroupWhereUniqueInput!): Group
  groups(where: GroupWhereInput, orderBy: GroupOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Group]!
  groupsConnection(where: GroupWhereInput, orderBy: GroupOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): GroupConnection!
  location(where: LocationWhereUniqueInput!): Location
  locations(where: LocationWhereInput, orderBy: LocationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Location]!
  locationsConnection(where: LocationWhereInput, orderBy: LocationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): LocationConnection!
  membership(where: MembershipWhereUniqueInput!): Membership
  memberships(where: MembershipWhereInput, orderBy: MembershipOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Membership]!
  membershipsConnection(where: MembershipWhereInput, orderBy: MembershipOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): MembershipConnection!
  session(where: SessionWhereUniqueInput!): Session
  sessions(where: SessionWhereInput, orderBy: SessionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Session]!
  sessionsConnection(where: SessionWhereInput, orderBy: SessionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): SessionConnection!
  tag(where: TagWhereUniqueInput!): Tag
  tags(where: TagWhereInput, orderBy: TagOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Tag]!
  tagsConnection(where: TagWhereInput, orderBy: TagOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): TagConnection!
  user(where: UserWhereUniqueInput!): User
  users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User]!
  usersConnection(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserConnection!
  node(id: ID!): Node
}

type Session {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime
  sessionToken: String!
  csrfToken: String
  bearerToken: String
  clientTime: String
  validTo: DateTime!
  timedOut: DateTime
  loggedOut: DateTime
  user: User!
  agent: Agent!
  location: Location
  ipAddress: String
}

type SessionConnection {
  pageInfo: PageInfo!
  edges: [SessionEdge]!
  aggregate: AggregateSession!
}

input SessionCreateInput {
  id: ID
  sessionToken: String!
  csrfToken: String
  bearerToken: String
  clientTime: String
  validTo: DateTime!
  timedOut: DateTime
  loggedOut: DateTime
  user: UserCreateOneWithoutSessionsInput!
  agent: AgentCreateOneInput!
  location: LocationCreateOneInput
  ipAddress: String
}

input SessionCreateManyWithoutUserInput {
  create: [SessionCreateWithoutUserInput!]
  connect: [SessionWhereUniqueInput!]
}

input SessionCreateWithoutUserInput {
  id: ID
  sessionToken: String!
  csrfToken: String
  bearerToken: String
  clientTime: String
  validTo: DateTime!
  timedOut: DateTime
  loggedOut: DateTime
  agent: AgentCreateOneInput!
  location: LocationCreateOneInput
  ipAddress: String
}

type SessionEdge {
  node: Session!
  cursor: String!
}

enum SessionOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  sessionToken_ASC
  sessionToken_DESC
  csrfToken_ASC
  csrfToken_DESC
  bearerToken_ASC
  bearerToken_DESC
  clientTime_ASC
  clientTime_DESC
  validTo_ASC
  validTo_DESC
  timedOut_ASC
  timedOut_DESC
  loggedOut_ASC
  loggedOut_DESC
  ipAddress_ASC
  ipAddress_DESC
}

type SessionPreviousValues {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime
  sessionToken: String!
  csrfToken: String
  bearerToken: String
  clientTime: String
  validTo: DateTime!
  timedOut: DateTime
  loggedOut: DateTime
  ipAddress: String
}

input SessionScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  sessionToken: String
  sessionToken_not: String
  sessionToken_in: [String!]
  sessionToken_not_in: [String!]
  sessionToken_lt: String
  sessionToken_lte: String
  sessionToken_gt: String
  sessionToken_gte: String
  sessionToken_contains: String
  sessionToken_not_contains: String
  sessionToken_starts_with: String
  sessionToken_not_starts_with: String
  sessionToken_ends_with: String
  sessionToken_not_ends_with: String
  csrfToken: String
  csrfToken_not: String
  csrfToken_in: [String!]
  csrfToken_not_in: [String!]
  csrfToken_lt: String
  csrfToken_lte: String
  csrfToken_gt: String
  csrfToken_gte: String
  csrfToken_contains: String
  csrfToken_not_contains: String
  csrfToken_starts_with: String
  csrfToken_not_starts_with: String
  csrfToken_ends_with: String
  csrfToken_not_ends_with: String
  bearerToken: String
  bearerToken_not: String
  bearerToken_in: [String!]
  bearerToken_not_in: [String!]
  bearerToken_lt: String
  bearerToken_lte: String
  bearerToken_gt: String
  bearerToken_gte: String
  bearerToken_contains: String
  bearerToken_not_contains: String
  bearerToken_starts_with: String
  bearerToken_not_starts_with: String
  bearerToken_ends_with: String
  bearerToken_not_ends_with: String
  clientTime: String
  clientTime_not: String
  clientTime_in: [String!]
  clientTime_not_in: [String!]
  clientTime_lt: String
  clientTime_lte: String
  clientTime_gt: String
  clientTime_gte: String
  clientTime_contains: String
  clientTime_not_contains: String
  clientTime_starts_with: String
  clientTime_not_starts_with: String
  clientTime_ends_with: String
  clientTime_not_ends_with: String
  validTo: DateTime
  validTo_not: DateTime
  validTo_in: [DateTime!]
  validTo_not_in: [DateTime!]
  validTo_lt: DateTime
  validTo_lte: DateTime
  validTo_gt: DateTime
  validTo_gte: DateTime
  timedOut: DateTime
  timedOut_not: DateTime
  timedOut_in: [DateTime!]
  timedOut_not_in: [DateTime!]
  timedOut_lt: DateTime
  timedOut_lte: DateTime
  timedOut_gt: DateTime
  timedOut_gte: DateTime
  loggedOut: DateTime
  loggedOut_not: DateTime
  loggedOut_in: [DateTime!]
  loggedOut_not_in: [DateTime!]
  loggedOut_lt: DateTime
  loggedOut_lte: DateTime
  loggedOut_gt: DateTime
  loggedOut_gte: DateTime
  ipAddress: String
  ipAddress_not: String
  ipAddress_in: [String!]
  ipAddress_not_in: [String!]
  ipAddress_lt: String
  ipAddress_lte: String
  ipAddress_gt: String
  ipAddress_gte: String
  ipAddress_contains: String
  ipAddress_not_contains: String
  ipAddress_starts_with: String
  ipAddress_not_starts_with: String
  ipAddress_ends_with: String
  ipAddress_not_ends_with: String
  AND: [SessionScalarWhereInput!]
  OR: [SessionScalarWhereInput!]
  NOT: [SessionScalarWhereInput!]
}

type SessionSubscriptionPayload {
  mutation: MutationType!
  node: Session
  updatedFields: [String!]
  previousValues: SessionPreviousValues
}

input SessionSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: SessionWhereInput
  AND: [SessionSubscriptionWhereInput!]
  OR: [SessionSubscriptionWhereInput!]
  NOT: [SessionSubscriptionWhereInput!]
}

input SessionUpdateInput {
  sessionToken: String
  csrfToken: String
  bearerToken: String
  clientTime: String
  validTo: DateTime
  timedOut: DateTime
  loggedOut: DateTime
  user: UserUpdateOneRequiredWithoutSessionsInput
  agent: AgentUpdateOneRequiredInput
  location: LocationUpdateOneInput
  ipAddress: String
}

input SessionUpdateManyDataInput {
  sessionToken: String
  csrfToken: String
  bearerToken: String
  clientTime: String
  validTo: DateTime
  timedOut: DateTime
  loggedOut: DateTime
  ipAddress: String
}

input SessionUpdateManyMutationInput {
  sessionToken: String
  csrfToken: String
  bearerToken: String
  clientTime: String
  validTo: DateTime
  timedOut: DateTime
  loggedOut: DateTime
  ipAddress: String
}

input SessionUpdateManyWithoutUserInput {
  create: [SessionCreateWithoutUserInput!]
  delete: [SessionWhereUniqueInput!]
  connect: [SessionWhereUniqueInput!]
  set: [SessionWhereUniqueInput!]
  disconnect: [SessionWhereUniqueInput!]
  update: [SessionUpdateWithWhereUniqueWithoutUserInput!]
  upsert: [SessionUpsertWithWhereUniqueWithoutUserInput!]
  deleteMany: [SessionScalarWhereInput!]
  updateMany: [SessionUpdateManyWithWhereNestedInput!]
}

input SessionUpdateManyWithWhereNestedInput {
  where: SessionScalarWhereInput!
  data: SessionUpdateManyDataInput!
}

input SessionUpdateWithoutUserDataInput {
  sessionToken: String
  csrfToken: String
  bearerToken: String
  clientTime: String
  validTo: DateTime
  timedOut: DateTime
  loggedOut: DateTime
  agent: AgentUpdateOneRequiredInput
  location: LocationUpdateOneInput
  ipAddress: String
}

input SessionUpdateWithWhereUniqueWithoutUserInput {
  where: SessionWhereUniqueInput!
  data: SessionUpdateWithoutUserDataInput!
}

input SessionUpsertWithWhereUniqueWithoutUserInput {
  where: SessionWhereUniqueInput!
  update: SessionUpdateWithoutUserDataInput!
  create: SessionCreateWithoutUserInput!
}

input SessionWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  sessionToken: String
  sessionToken_not: String
  sessionToken_in: [String!]
  sessionToken_not_in: [String!]
  sessionToken_lt: String
  sessionToken_lte: String
  sessionToken_gt: String
  sessionToken_gte: String
  sessionToken_contains: String
  sessionToken_not_contains: String
  sessionToken_starts_with: String
  sessionToken_not_starts_with: String
  sessionToken_ends_with: String
  sessionToken_not_ends_with: String
  csrfToken: String
  csrfToken_not: String
  csrfToken_in: [String!]
  csrfToken_not_in: [String!]
  csrfToken_lt: String
  csrfToken_lte: String
  csrfToken_gt: String
  csrfToken_gte: String
  csrfToken_contains: String
  csrfToken_not_contains: String
  csrfToken_starts_with: String
  csrfToken_not_starts_with: String
  csrfToken_ends_with: String
  csrfToken_not_ends_with: String
  bearerToken: String
  bearerToken_not: String
  bearerToken_in: [String!]
  bearerToken_not_in: [String!]
  bearerToken_lt: String
  bearerToken_lte: String
  bearerToken_gt: String
  bearerToken_gte: String
  bearerToken_contains: String
  bearerToken_not_contains: String
  bearerToken_starts_with: String
  bearerToken_not_starts_with: String
  bearerToken_ends_with: String
  bearerToken_not_ends_with: String
  clientTime: String
  clientTime_not: String
  clientTime_in: [String!]
  clientTime_not_in: [String!]
  clientTime_lt: String
  clientTime_lte: String
  clientTime_gt: String
  clientTime_gte: String
  clientTime_contains: String
  clientTime_not_contains: String
  clientTime_starts_with: String
  clientTime_not_starts_with: String
  clientTime_ends_with: String
  clientTime_not_ends_with: String
  validTo: DateTime
  validTo_not: DateTime
  validTo_in: [DateTime!]
  validTo_not_in: [DateTime!]
  validTo_lt: DateTime
  validTo_lte: DateTime
  validTo_gt: DateTime
  validTo_gte: DateTime
  timedOut: DateTime
  timedOut_not: DateTime
  timedOut_in: [DateTime!]
  timedOut_not_in: [DateTime!]
  timedOut_lt: DateTime
  timedOut_lte: DateTime
  timedOut_gt: DateTime
  timedOut_gte: DateTime
  loggedOut: DateTime
  loggedOut_not: DateTime
  loggedOut_in: [DateTime!]
  loggedOut_not_in: [DateTime!]
  loggedOut_lt: DateTime
  loggedOut_lte: DateTime
  loggedOut_gt: DateTime
  loggedOut_gte: DateTime
  user: UserWhereInput
  agent: AgentWhereInput
  location: LocationWhereInput
  ipAddress: String
  ipAddress_not: String
  ipAddress_in: [String!]
  ipAddress_not_in: [String!]
  ipAddress_lt: String
  ipAddress_lte: String
  ipAddress_gt: String
  ipAddress_gte: String
  ipAddress_contains: String
  ipAddress_not_contains: String
  ipAddress_starts_with: String
  ipAddress_not_starts_with: String
  ipAddress_ends_with: String
  ipAddress_not_ends_with: String
  AND: [SessionWhereInput!]
  OR: [SessionWhereInput!]
  NOT: [SessionWhereInput!]
}

input SessionWhereUniqueInput {
  id: ID
  sessionToken: String
}

type Subscription {
  agent(where: AgentSubscriptionWhereInput): AgentSubscriptionPayload
  contentEncoding(where: ContentEncodingSubscriptionWhereInput): ContentEncodingSubscriptionPayload
  entry(where: EntrySubscriptionWhereInput): EntrySubscriptionPayload
  group(where: GroupSubscriptionWhereInput): GroupSubscriptionPayload
  location(where: LocationSubscriptionWhereInput): LocationSubscriptionPayload
  membership(where: MembershipSubscriptionWhereInput): MembershipSubscriptionPayload
  session(where: SessionSubscriptionWhereInput): SessionSubscriptionPayload
  tag(where: TagSubscriptionWhereInput): TagSubscriptionPayload
  user(where: UserSubscriptionWhereInput): UserSubscriptionPayload
}

type Tag {
  id: ID!
  type: String!
  isPrivate: Boolean!
  owner: ID!
  createdBy: ID!
  createdAt: DateTime!
  value: String!
}

type TagConnection {
  pageInfo: PageInfo!
  edges: [TagEdge]!
  aggregate: AggregateTag!
}

input TagCreateInput {
  id: ID
  type: String!
  isPrivate: Boolean!
  owner: ID!
  createdBy: ID!
  value: String!
}

input TagCreateManyInput {
  create: [TagCreateInput!]
  connect: [TagWhereUniqueInput!]
}

type TagEdge {
  node: Tag!
  cursor: String!
}

enum TagOrderByInput {
  id_ASC
  id_DESC
  type_ASC
  type_DESC
  isPrivate_ASC
  isPrivate_DESC
  owner_ASC
  owner_DESC
  createdBy_ASC
  createdBy_DESC
  createdAt_ASC
  createdAt_DESC
  value_ASC
  value_DESC
}

type TagPreviousValues {
  id: ID!
  type: String!
  isPrivate: Boolean!
  owner: ID!
  createdBy: ID!
  createdAt: DateTime!
  value: String!
}

input TagScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  type: String
  type_not: String
  type_in: [String!]
  type_not_in: [String!]
  type_lt: String
  type_lte: String
  type_gt: String
  type_gte: String
  type_contains: String
  type_not_contains: String
  type_starts_with: String
  type_not_starts_with: String
  type_ends_with: String
  type_not_ends_with: String
  isPrivate: Boolean
  isPrivate_not: Boolean
  owner: ID
  owner_not: ID
  owner_in: [ID!]
  owner_not_in: [ID!]
  owner_lt: ID
  owner_lte: ID
  owner_gt: ID
  owner_gte: ID
  owner_contains: ID
  owner_not_contains: ID
  owner_starts_with: ID
  owner_not_starts_with: ID
  owner_ends_with: ID
  owner_not_ends_with: ID
  createdBy: ID
  createdBy_not: ID
  createdBy_in: [ID!]
  createdBy_not_in: [ID!]
  createdBy_lt: ID
  createdBy_lte: ID
  createdBy_gt: ID
  createdBy_gte: ID
  createdBy_contains: ID
  createdBy_not_contains: ID
  createdBy_starts_with: ID
  createdBy_not_starts_with: ID
  createdBy_ends_with: ID
  createdBy_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  value: String
  value_not: String
  value_in: [String!]
  value_not_in: [String!]
  value_lt: String
  value_lte: String
  value_gt: String
  value_gte: String
  value_contains: String
  value_not_contains: String
  value_starts_with: String
  value_not_starts_with: String
  value_ends_with: String
  value_not_ends_with: String
  AND: [TagScalarWhereInput!]
  OR: [TagScalarWhereInput!]
  NOT: [TagScalarWhereInput!]
}

type TagSubscriptionPayload {
  mutation: MutationType!
  node: Tag
  updatedFields: [String!]
  previousValues: TagPreviousValues
}

input TagSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: TagWhereInput
  AND: [TagSubscriptionWhereInput!]
  OR: [TagSubscriptionWhereInput!]
  NOT: [TagSubscriptionWhereInput!]
}

input TagUpdateDataInput {
  type: String
  isPrivate: Boolean
  owner: ID
  createdBy: ID
  value: String
}

input TagUpdateInput {
  type: String
  isPrivate: Boolean
  owner: ID
  createdBy: ID
  value: String
}

input TagUpdateManyDataInput {
  type: String
  isPrivate: Boolean
  owner: ID
  createdBy: ID
  value: String
}

input TagUpdateManyInput {
  create: [TagCreateInput!]
  update: [TagUpdateWithWhereUniqueNestedInput!]
  upsert: [TagUpsertWithWhereUniqueNestedInput!]
  delete: [TagWhereUniqueInput!]
  connect: [TagWhereUniqueInput!]
  set: [TagWhereUniqueInput!]
  disconnect: [TagWhereUniqueInput!]
  deleteMany: [TagScalarWhereInput!]
  updateMany: [TagUpdateManyWithWhereNestedInput!]
}

input TagUpdateManyMutationInput {
  type: String
  isPrivate: Boolean
  owner: ID
  createdBy: ID
  value: String
}

input TagUpdateManyWithWhereNestedInput {
  where: TagScalarWhereInput!
  data: TagUpdateManyDataInput!
}

input TagUpdateWithWhereUniqueNestedInput {
  where: TagWhereUniqueInput!
  data: TagUpdateDataInput!
}

input TagUpsertWithWhereUniqueNestedInput {
  where: TagWhereUniqueInput!
  update: TagUpdateDataInput!
  create: TagCreateInput!
}

input TagWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  type: String
  type_not: String
  type_in: [String!]
  type_not_in: [String!]
  type_lt: String
  type_lte: String
  type_gt: String
  type_gte: String
  type_contains: String
  type_not_contains: String
  type_starts_with: String
  type_not_starts_with: String
  type_ends_with: String
  type_not_ends_with: String
  isPrivate: Boolean
  isPrivate_not: Boolean
  owner: ID
  owner_not: ID
  owner_in: [ID!]
  owner_not_in: [ID!]
  owner_lt: ID
  owner_lte: ID
  owner_gt: ID
  owner_gte: ID
  owner_contains: ID
  owner_not_contains: ID
  owner_starts_with: ID
  owner_not_starts_with: ID
  owner_ends_with: ID
  owner_not_ends_with: ID
  createdBy: ID
  createdBy_not: ID
  createdBy_in: [ID!]
  createdBy_not_in: [ID!]
  createdBy_lt: ID
  createdBy_lte: ID
  createdBy_gt: ID
  createdBy_gte: ID
  createdBy_contains: ID
  createdBy_not_contains: ID
  createdBy_starts_with: ID
  createdBy_not_starts_with: ID
  createdBy_ends_with: ID
  createdBy_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  value: String
  value_not: String
  value_in: [String!]
  value_not_in: [String!]
  value_lt: String
  value_lte: String
  value_gt: String
  value_gte: String
  value_contains: String
  value_not_contains: String
  value_starts_with: String
  value_not_starts_with: String
  value_ends_with: String
  value_not_ends_with: String
  AND: [TagWhereInput!]
  OR: [TagWhereInput!]
  NOT: [TagWhereInput!]
}

input TagWhereUniqueInput {
  id: ID
}

type User {
  id: ID!
  type: UserType!
  createdAt: DateTime!
  updatedAt: DateTime
  email: String!
  timezone: String!
  challenge: String
  passwordSalt: String
  passwordHash: String
  agents(where: AgentWhereInput, orderBy: AgentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Agent!]
  sessions(where: SessionWhereInput, orderBy: SessionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Session!]
  firstName: String
  lastName: String
  phone: String
  mobilePhone: String
  organizationName: String
}

type UserConnection {
  pageInfo: PageInfo!
  edges: [UserEdge]!
  aggregate: AggregateUser!
}

input UserCreateInput {
  id: ID
  type: UserType!
  email: String!
  timezone: String!
  challenge: String
  passwordSalt: String
  passwordHash: String
  agents: AgentCreateManyInput
  sessions: SessionCreateManyWithoutUserInput
  firstName: String
  lastName: String
  phone: String
  mobilePhone: String
  organizationName: String
}

input UserCreateOneWithoutSessionsInput {
  create: UserCreateWithoutSessionsInput
  connect: UserWhereUniqueInput
}

input UserCreateWithoutSessionsInput {
  id: ID
  type: UserType!
  email: String!
  timezone: String!
  challenge: String
  passwordSalt: String
  passwordHash: String
  agents: AgentCreateManyInput
  firstName: String
  lastName: String
  phone: String
  mobilePhone: String
  organizationName: String
}

type UserEdge {
  node: User!
  cursor: String!
}

enum UserOrderByInput {
  id_ASC
  id_DESC
  type_ASC
  type_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  email_ASC
  email_DESC
  timezone_ASC
  timezone_DESC
  challenge_ASC
  challenge_DESC
  passwordSalt_ASC
  passwordSalt_DESC
  passwordHash_ASC
  passwordHash_DESC
  firstName_ASC
  firstName_DESC
  lastName_ASC
  lastName_DESC
  phone_ASC
  phone_DESC
  mobilePhone_ASC
  mobilePhone_DESC
  organizationName_ASC
  organizationName_DESC
}

type UserPreviousValues {
  id: ID!
  type: UserType!
  createdAt: DateTime!
  updatedAt: DateTime
  email: String!
  timezone: String!
  challenge: String
  passwordSalt: String
  passwordHash: String
  firstName: String
  lastName: String
  phone: String
  mobilePhone: String
  organizationName: String
}

type UserSubscriptionPayload {
  mutation: MutationType!
  node: User
  updatedFields: [String!]
  previousValues: UserPreviousValues
}

input UserSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UserWhereInput
  AND: [UserSubscriptionWhereInput!]
  OR: [UserSubscriptionWhereInput!]
  NOT: [UserSubscriptionWhereInput!]
}

enum UserType {
  Person
  System
}

input UserUpdateInput {
  type: UserType
  email: String
  timezone: String
  challenge: String
  passwordSalt: String
  passwordHash: String
  agents: AgentUpdateManyInput
  sessions: SessionUpdateManyWithoutUserInput
  firstName: String
  lastName: String
  phone: String
  mobilePhone: String
  organizationName: String
}

input UserUpdateManyMutationInput {
  type: UserType
  email: String
  timezone: String
  challenge: String
  passwordSalt: String
  passwordHash: String
  firstName: String
  lastName: String
  phone: String
  mobilePhone: String
  organizationName: String
}

input UserUpdateOneRequiredWithoutSessionsInput {
  create: UserCreateWithoutSessionsInput
  update: UserUpdateWithoutSessionsDataInput
  upsert: UserUpsertWithoutSessionsInput
  connect: UserWhereUniqueInput
}

input UserUpdateWithoutSessionsDataInput {
  type: UserType
  email: String
  timezone: String
  challenge: String
  passwordSalt: String
  passwordHash: String
  agents: AgentUpdateManyInput
  firstName: String
  lastName: String
  phone: String
  mobilePhone: String
  organizationName: String
}

input UserUpsertWithoutSessionsInput {
  update: UserUpdateWithoutSessionsDataInput!
  create: UserCreateWithoutSessionsInput!
}

input UserWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  type: UserType
  type_not: UserType
  type_in: [UserType!]
  type_not_in: [UserType!]
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  timezone: String
  timezone_not: String
  timezone_in: [String!]
  timezone_not_in: [String!]
  timezone_lt: String
  timezone_lte: String
  timezone_gt: String
  timezone_gte: String
  timezone_contains: String
  timezone_not_contains: String
  timezone_starts_with: String
  timezone_not_starts_with: String
  timezone_ends_with: String
  timezone_not_ends_with: String
  challenge: String
  challenge_not: String
  challenge_in: [String!]
  challenge_not_in: [String!]
  challenge_lt: String
  challenge_lte: String
  challenge_gt: String
  challenge_gte: String
  challenge_contains: String
  challenge_not_contains: String
  challenge_starts_with: String
  challenge_not_starts_with: String
  challenge_ends_with: String
  challenge_not_ends_with: String
  passwordSalt: String
  passwordSalt_not: String
  passwordSalt_in: [String!]
  passwordSalt_not_in: [String!]
  passwordSalt_lt: String
  passwordSalt_lte: String
  passwordSalt_gt: String
  passwordSalt_gte: String
  passwordSalt_contains: String
  passwordSalt_not_contains: String
  passwordSalt_starts_with: String
  passwordSalt_not_starts_with: String
  passwordSalt_ends_with: String
  passwordSalt_not_ends_with: String
  passwordHash: String
  passwordHash_not: String
  passwordHash_in: [String!]
  passwordHash_not_in: [String!]
  passwordHash_lt: String
  passwordHash_lte: String
  passwordHash_gt: String
  passwordHash_gte: String
  passwordHash_contains: String
  passwordHash_not_contains: String
  passwordHash_starts_with: String
  passwordHash_not_starts_with: String
  passwordHash_ends_with: String
  passwordHash_not_ends_with: String
  agents_every: AgentWhereInput
  agents_some: AgentWhereInput
  agents_none: AgentWhereInput
  sessions_every: SessionWhereInput
  sessions_some: SessionWhereInput
  sessions_none: SessionWhereInput
  firstName: String
  firstName_not: String
  firstName_in: [String!]
  firstName_not_in: [String!]
  firstName_lt: String
  firstName_lte: String
  firstName_gt: String
  firstName_gte: String
  firstName_contains: String
  firstName_not_contains: String
  firstName_starts_with: String
  firstName_not_starts_with: String
  firstName_ends_with: String
  firstName_not_ends_with: String
  lastName: String
  lastName_not: String
  lastName_in: [String!]
  lastName_not_in: [String!]
  lastName_lt: String
  lastName_lte: String
  lastName_gt: String
  lastName_gte: String
  lastName_contains: String
  lastName_not_contains: String
  lastName_starts_with: String
  lastName_not_starts_with: String
  lastName_ends_with: String
  lastName_not_ends_with: String
  phone: String
  phone_not: String
  phone_in: [String!]
  phone_not_in: [String!]
  phone_lt: String
  phone_lte: String
  phone_gt: String
  phone_gte: String
  phone_contains: String
  phone_not_contains: String
  phone_starts_with: String
  phone_not_starts_with: String
  phone_ends_with: String
  phone_not_ends_with: String
  mobilePhone: String
  mobilePhone_not: String
  mobilePhone_in: [String!]
  mobilePhone_not_in: [String!]
  mobilePhone_lt: String
  mobilePhone_lte: String
  mobilePhone_gt: String
  mobilePhone_gte: String
  mobilePhone_contains: String
  mobilePhone_not_contains: String
  mobilePhone_starts_with: String
  mobilePhone_not_starts_with: String
  mobilePhone_ends_with: String
  mobilePhone_not_ends_with: String
  organizationName: String
  organizationName_not: String
  organizationName_in: [String!]
  organizationName_not_in: [String!]
  organizationName_lt: String
  organizationName_lte: String
  organizationName_gt: String
  organizationName_gte: String
  organizationName_contains: String
  organizationName_not_contains: String
  organizationName_starts_with: String
  organizationName_not_starts_with: String
  organizationName_ends_with: String
  organizationName_not_ends_with: String
  AND: [UserWhereInput!]
  OR: [UserWhereInput!]
  NOT: [UserWhereInput!]
}

input UserWhereUniqueInput {
  id: ID
  email: String
}
`

export class EntryWhereInput {
}