// Code generated by Prisma (prisma@1.34.3). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

export const typeDefs = /* GraphQL */ `type AggregateEvent {
  count: Int!
}

type AggregateGroup {
  count: Int!
}

type AggregateLocation {
  count: Int!
}

type AggregateMembership {
  count: Int!
}

type AggregateProfile {
  count: Int!
}

type AggregateSession {
  count: Int!
}

type AggregateTag {
  count: Int!
}

type AggregateUser {
  count: Int!
}

type BatchPayload {
  count: Long!
}

scalar DateTime

type Event {
  id: ID!
  createdAt: DateTime!
  parent: Event
  creator: Profile!
  type: EventType!
  isPinned: Boolean!
  isRead: Boolean!
  content: Json
  location: Location!
  tags(where: TagWhereInput, orderBy: TagOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Tag!]
}

type EventConnection {
  pageInfo: PageInfo!
  edges: [EventEdge]!
  aggregate: AggregateEvent!
}

input EventCreateInput {
  id: ID
  parent: EventCreateOneInput
  creator: ProfileCreateOneInput!
  type: EventType!
  isPinned: Boolean!
  isRead: Boolean!
  content: Json
  location: LocationCreateOneInput!
  tags: TagCreateManyInput
}

input EventCreateManyInput {
  create: [EventCreateInput!]
  connect: [EventWhereUniqueInput!]
}

input EventCreateOneInput {
  create: EventCreateInput
  connect: EventWhereUniqueInput
}

type EventEdge {
  node: Event!
  cursor: String!
}

enum EventOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  type_ASC
  type_DESC
  isPinned_ASC
  isPinned_DESC
  isRead_ASC
  isRead_DESC
  content_ASC
  content_DESC
}

type EventPreviousValues {
  id: ID!
  createdAt: DateTime!
  type: EventType!
  isPinned: Boolean!
  isRead: Boolean!
  content: Json
}

input EventScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  type: EventType
  type_not: EventType
  type_in: [EventType!]
  type_not_in: [EventType!]
  isPinned: Boolean
  isPinned_not: Boolean
  isRead: Boolean
  isRead_not: Boolean
  AND: [EventScalarWhereInput!]
  OR: [EventScalarWhereInput!]
  NOT: [EventScalarWhereInput!]
}

type EventSubscriptionPayload {
  mutation: MutationType!
  node: Event
  updatedFields: [String!]
  previousValues: EventPreviousValues
}

input EventSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: EventWhereInput
  AND: [EventSubscriptionWhereInput!]
  OR: [EventSubscriptionWhereInput!]
  NOT: [EventSubscriptionWhereInput!]
}

enum EventType {
  NOTIFICATION
  DIRECT_MESSAGE
  COMMENT
  POST
  REACTION
}

input EventUpdateDataInput {
  parent: EventUpdateOneInput
  creator: ProfileUpdateOneRequiredInput
  type: EventType
  isPinned: Boolean
  isRead: Boolean
  content: Json
  location: LocationUpdateOneRequiredInput
  tags: TagUpdateManyInput
}

input EventUpdateInput {
  parent: EventUpdateOneInput
  creator: ProfileUpdateOneRequiredInput
  type: EventType
  isPinned: Boolean
  isRead: Boolean
  content: Json
  location: LocationUpdateOneRequiredInput
  tags: TagUpdateManyInput
}

input EventUpdateManyDataInput {
  type: EventType
  isPinned: Boolean
  isRead: Boolean
  content: Json
}

input EventUpdateManyInput {
  create: [EventCreateInput!]
  update: [EventUpdateWithWhereUniqueNestedInput!]
  upsert: [EventUpsertWithWhereUniqueNestedInput!]
  delete: [EventWhereUniqueInput!]
  connect: [EventWhereUniqueInput!]
  set: [EventWhereUniqueInput!]
  disconnect: [EventWhereUniqueInput!]
  deleteMany: [EventScalarWhereInput!]
  updateMany: [EventUpdateManyWithWhereNestedInput!]
}

input EventUpdateManyMutationInput {
  type: EventType
  isPinned: Boolean
  isRead: Boolean
  content: Json
}

input EventUpdateManyWithWhereNestedInput {
  where: EventScalarWhereInput!
  data: EventUpdateManyDataInput!
}

input EventUpdateOneInput {
  create: EventCreateInput
  update: EventUpdateDataInput
  upsert: EventUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: EventWhereUniqueInput
}

input EventUpdateWithWhereUniqueNestedInput {
  where: EventWhereUniqueInput!
  data: EventUpdateDataInput!
}

input EventUpsertNestedInput {
  update: EventUpdateDataInput!
  create: EventCreateInput!
}

input EventUpsertWithWhereUniqueNestedInput {
  where: EventWhereUniqueInput!
  update: EventUpdateDataInput!
  create: EventCreateInput!
}

input EventWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  parent: EventWhereInput
  creator: ProfileWhereInput
  type: EventType
  type_not: EventType
  type_in: [EventType!]
  type_not_in: [EventType!]
  isPinned: Boolean
  isPinned_not: Boolean
  isRead: Boolean
  isRead_not: Boolean
  location: LocationWhereInput
  tags_every: TagWhereInput
  tags_some: TagWhereInput
  tags_none: TagWhereInput
  AND: [EventWhereInput!]
  OR: [EventWhereInput!]
  NOT: [EventWhereInput!]
}

input EventWhereUniqueInput {
  id: ID
}

type Group {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime
  creator: Profile!
  name: String!
  title: String
  description: String
  pictureLogo: String!
  pictureBanner: String
  type: GroupType!
  parent: Group
  isHidden: Boolean!
  isPublic: Boolean!
  members(where: MembershipWhereInput, orderBy: MembershipOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Membership!]
  events(where: EventWhereInput, orderBy: EventOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Event!]
  tags(where: TagWhereInput, orderBy: TagOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Tag!]
  location: Location
  membersCount: Int!
  membersOnline: Int!
  eventsCount: Int!
}

type GroupConnection {
  pageInfo: PageInfo!
  edges: [GroupEdge]!
  aggregate: AggregateGroup!
}

input GroupCreateInput {
  id: ID
  creator: ProfileCreateOneInput!
  name: String!
  title: String
  description: String
  pictureLogo: String!
  pictureBanner: String
  type: GroupType!
  parent: GroupCreateOneInput
  isHidden: Boolean!
  isPublic: Boolean!
  members: MembershipCreateManyWithoutGroupInput
  events: EventCreateManyInput
  tags: TagCreateManyInput
  location: LocationCreateOneInput
  membersCount: Int!
  membersOnline: Int!
  eventsCount: Int!
}

input GroupCreateOneInput {
  create: GroupCreateInput
  connect: GroupWhereUniqueInput
}

input GroupCreateOneWithoutMembersInput {
  create: GroupCreateWithoutMembersInput
  connect: GroupWhereUniqueInput
}

input GroupCreateWithoutMembersInput {
  id: ID
  creator: ProfileCreateOneInput!
  name: String!
  title: String
  description: String
  pictureLogo: String!
  pictureBanner: String
  type: GroupType!
  parent: GroupCreateOneInput
  isHidden: Boolean!
  isPublic: Boolean!
  events: EventCreateManyInput
  tags: TagCreateManyInput
  location: LocationCreateOneInput
  membersCount: Int!
  membersOnline: Int!
  eventsCount: Int!
}

type GroupEdge {
  node: Group!
  cursor: String!
}

enum GroupOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  name_ASC
  name_DESC
  title_ASC
  title_DESC
  description_ASC
  description_DESC
  pictureLogo_ASC
  pictureLogo_DESC
  pictureBanner_ASC
  pictureBanner_DESC
  type_ASC
  type_DESC
  isHidden_ASC
  isHidden_DESC
  isPublic_ASC
  isPublic_DESC
  membersCount_ASC
  membersCount_DESC
  membersOnline_ASC
  membersOnline_DESC
  eventsCount_ASC
  eventsCount_DESC
}

type GroupPreviousValues {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime
  name: String!
  title: String
  description: String
  pictureLogo: String!
  pictureBanner: String
  type: GroupType!
  isHidden: Boolean!
  isPublic: Boolean!
  membersCount: Int!
  membersOnline: Int!
  eventsCount: Int!
}

type GroupSubscriptionPayload {
  mutation: MutationType!
  node: Group
  updatedFields: [String!]
  previousValues: GroupPreviousValues
}

input GroupSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: GroupWhereInput
  AND: [GroupSubscriptionWhereInput!]
  OR: [GroupSubscriptionWhereInput!]
  NOT: [GroupSubscriptionWhereInput!]
}

enum GroupType {
  ROOM
  CHANNEL
  THREAD
  CONTACTS
  FOLLOWERS
}

input GroupUpdateDataInput {
  creator: ProfileUpdateOneRequiredInput
  name: String
  title: String
  description: String
  pictureLogo: String
  pictureBanner: String
  type: GroupType
  parent: GroupUpdateOneInput
  isHidden: Boolean
  isPublic: Boolean
  members: MembershipUpdateManyWithoutGroupInput
  events: EventUpdateManyInput
  tags: TagUpdateManyInput
  location: LocationUpdateOneInput
  membersCount: Int
  membersOnline: Int
  eventsCount: Int
}

input GroupUpdateInput {
  creator: ProfileUpdateOneRequiredInput
  name: String
  title: String
  description: String
  pictureLogo: String
  pictureBanner: String
  type: GroupType
  parent: GroupUpdateOneInput
  isHidden: Boolean
  isPublic: Boolean
  members: MembershipUpdateManyWithoutGroupInput
  events: EventUpdateManyInput
  tags: TagUpdateManyInput
  location: LocationUpdateOneInput
  membersCount: Int
  membersOnline: Int
  eventsCount: Int
}

input GroupUpdateManyMutationInput {
  name: String
  title: String
  description: String
  pictureLogo: String
  pictureBanner: String
  type: GroupType
  isHidden: Boolean
  isPublic: Boolean
  membersCount: Int
  membersOnline: Int
  eventsCount: Int
}

input GroupUpdateOneInput {
  create: GroupCreateInput
  update: GroupUpdateDataInput
  upsert: GroupUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: GroupWhereUniqueInput
}

input GroupUpdateOneRequiredWithoutMembersInput {
  create: GroupCreateWithoutMembersInput
  update: GroupUpdateWithoutMembersDataInput
  upsert: GroupUpsertWithoutMembersInput
  connect: GroupWhereUniqueInput
}

input GroupUpdateWithoutMembersDataInput {
  creator: ProfileUpdateOneRequiredInput
  name: String
  title: String
  description: String
  pictureLogo: String
  pictureBanner: String
  type: GroupType
  parent: GroupUpdateOneInput
  isHidden: Boolean
  isPublic: Boolean
  events: EventUpdateManyInput
  tags: TagUpdateManyInput
  location: LocationUpdateOneInput
  membersCount: Int
  membersOnline: Int
  eventsCount: Int
}

input GroupUpsertNestedInput {
  update: GroupUpdateDataInput!
  create: GroupCreateInput!
}

input GroupUpsertWithoutMembersInput {
  update: GroupUpdateWithoutMembersDataInput!
  create: GroupCreateWithoutMembersInput!
}

input GroupWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  creator: ProfileWhereInput
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  pictureLogo: String
  pictureLogo_not: String
  pictureLogo_in: [String!]
  pictureLogo_not_in: [String!]
  pictureLogo_lt: String
  pictureLogo_lte: String
  pictureLogo_gt: String
  pictureLogo_gte: String
  pictureLogo_contains: String
  pictureLogo_not_contains: String
  pictureLogo_starts_with: String
  pictureLogo_not_starts_with: String
  pictureLogo_ends_with: String
  pictureLogo_not_ends_with: String
  pictureBanner: String
  pictureBanner_not: String
  pictureBanner_in: [String!]
  pictureBanner_not_in: [String!]
  pictureBanner_lt: String
  pictureBanner_lte: String
  pictureBanner_gt: String
  pictureBanner_gte: String
  pictureBanner_contains: String
  pictureBanner_not_contains: String
  pictureBanner_starts_with: String
  pictureBanner_not_starts_with: String
  pictureBanner_ends_with: String
  pictureBanner_not_ends_with: String
  type: GroupType
  type_not: GroupType
  type_in: [GroupType!]
  type_not_in: [GroupType!]
  parent: GroupWhereInput
  isHidden: Boolean
  isHidden_not: Boolean
  isPublic: Boolean
  isPublic_not: Boolean
  members_every: MembershipWhereInput
  members_some: MembershipWhereInput
  members_none: MembershipWhereInput
  events_every: EventWhereInput
  events_some: EventWhereInput
  events_none: EventWhereInput
  tags_every: TagWhereInput
  tags_some: TagWhereInput
  tags_none: TagWhereInput
  location: LocationWhereInput
  membersCount: Int
  membersCount_not: Int
  membersCount_in: [Int!]
  membersCount_not_in: [Int!]
  membersCount_lt: Int
  membersCount_lte: Int
  membersCount_gt: Int
  membersCount_gte: Int
  membersOnline: Int
  membersOnline_not: Int
  membersOnline_in: [Int!]
  membersOnline_not_in: [Int!]
  membersOnline_lt: Int
  membersOnline_lte: Int
  membersOnline_gt: Int
  membersOnline_gte: Int
  eventsCount: Int
  eventsCount_not: Int
  eventsCount_in: [Int!]
  eventsCount_not_in: [Int!]
  eventsCount_lt: Int
  eventsCount_lte: Int
  eventsCount_gt: Int
  eventsCount_gte: Int
  AND: [GroupWhereInput!]
  OR: [GroupWhereInput!]
  NOT: [GroupWhereInput!]
}

input GroupWhereUniqueInput {
  id: ID
}

scalar Json

type Location {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  creator: Profile!
  type: LocationType!
  name: String!
  category: String
  address: String
  zipCode: String
  city: String
  country: String
  continent: String
  planet: String
  latitude: Float!
  longitude: Float!
  radiusMeter: Float
  tags(where: TagWhereInput, orderBy: TagOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Tag!]
  visitorsCount: Int!
}

type LocationConnection {
  pageInfo: PageInfo!
  edges: [LocationEdge]!
  aggregate: AggregateLocation!
}

input LocationCreateInput {
  id: ID
  creator: ProfileCreateOneInput!
  type: LocationType!
  name: String!
  category: String
  address: String
  zipCode: String
  city: String
  country: String
  continent: String
  planet: String
  latitude: Float!
  longitude: Float!
  radiusMeter: Float
  tags: TagCreateManyInput
  visitorsCount: Int!
}

input LocationCreateOneInput {
  create: LocationCreateInput
  connect: LocationWhereUniqueInput
}

type LocationEdge {
  node: Location!
  cursor: String!
}

enum LocationOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  type_ASC
  type_DESC
  name_ASC
  name_DESC
  category_ASC
  category_DESC
  address_ASC
  address_DESC
  zipCode_ASC
  zipCode_DESC
  city_ASC
  city_DESC
  country_ASC
  country_DESC
  continent_ASC
  continent_DESC
  planet_ASC
  planet_DESC
  latitude_ASC
  latitude_DESC
  longitude_ASC
  longitude_DESC
  radiusMeter_ASC
  radiusMeter_DESC
  visitorsCount_ASC
  visitorsCount_DESC
}

type LocationPreviousValues {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  type: LocationType!
  name: String!
  category: String
  address: String
  zipCode: String
  city: String
  country: String
  continent: String
  planet: String
  latitude: Float!
  longitude: Float!
  radiusMeter: Float
  visitorsCount: Int!
}

type LocationSubscriptionPayload {
  mutation: MutationType!
  node: Location
  updatedFields: [String!]
  previousValues: LocationPreviousValues
}

input LocationSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: LocationWhereInput
  AND: [LocationSubscriptionWhereInput!]
  OR: [LocationSubscriptionWhereInput!]
  NOT: [LocationSubscriptionWhereInput!]
}

enum LocationType {
  GEOGRAPHIC
  POI
}

input LocationUpdateDataInput {
  creator: ProfileUpdateOneRequiredInput
  type: LocationType
  name: String
  category: String
  address: String
  zipCode: String
  city: String
  country: String
  continent: String
  planet: String
  latitude: Float
  longitude: Float
  radiusMeter: Float
  tags: TagUpdateManyInput
  visitorsCount: Int
}

input LocationUpdateInput {
  creator: ProfileUpdateOneRequiredInput
  type: LocationType
  name: String
  category: String
  address: String
  zipCode: String
  city: String
  country: String
  continent: String
  planet: String
  latitude: Float
  longitude: Float
  radiusMeter: Float
  tags: TagUpdateManyInput
  visitorsCount: Int
}

input LocationUpdateManyMutationInput {
  type: LocationType
  name: String
  category: String
  address: String
  zipCode: String
  city: String
  country: String
  continent: String
  planet: String
  latitude: Float
  longitude: Float
  radiusMeter: Float
  visitorsCount: Int
}

input LocationUpdateOneInput {
  create: LocationCreateInput
  update: LocationUpdateDataInput
  upsert: LocationUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: LocationWhereUniqueInput
}

input LocationUpdateOneRequiredInput {
  create: LocationCreateInput
  update: LocationUpdateDataInput
  upsert: LocationUpsertNestedInput
  connect: LocationWhereUniqueInput
}

input LocationUpsertNestedInput {
  update: LocationUpdateDataInput!
  create: LocationCreateInput!
}

input LocationWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  creator: ProfileWhereInput
  type: LocationType
  type_not: LocationType
  type_in: [LocationType!]
  type_not_in: [LocationType!]
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  category: String
  category_not: String
  category_in: [String!]
  category_not_in: [String!]
  category_lt: String
  category_lte: String
  category_gt: String
  category_gte: String
  category_contains: String
  category_not_contains: String
  category_starts_with: String
  category_not_starts_with: String
  category_ends_with: String
  category_not_ends_with: String
  address: String
  address_not: String
  address_in: [String!]
  address_not_in: [String!]
  address_lt: String
  address_lte: String
  address_gt: String
  address_gte: String
  address_contains: String
  address_not_contains: String
  address_starts_with: String
  address_not_starts_with: String
  address_ends_with: String
  address_not_ends_with: String
  zipCode: String
  zipCode_not: String
  zipCode_in: [String!]
  zipCode_not_in: [String!]
  zipCode_lt: String
  zipCode_lte: String
  zipCode_gt: String
  zipCode_gte: String
  zipCode_contains: String
  zipCode_not_contains: String
  zipCode_starts_with: String
  zipCode_not_starts_with: String
  zipCode_ends_with: String
  zipCode_not_ends_with: String
  city: String
  city_not: String
  city_in: [String!]
  city_not_in: [String!]
  city_lt: String
  city_lte: String
  city_gt: String
  city_gte: String
  city_contains: String
  city_not_contains: String
  city_starts_with: String
  city_not_starts_with: String
  city_ends_with: String
  city_not_ends_with: String
  country: String
  country_not: String
  country_in: [String!]
  country_not_in: [String!]
  country_lt: String
  country_lte: String
  country_gt: String
  country_gte: String
  country_contains: String
  country_not_contains: String
  country_starts_with: String
  country_not_starts_with: String
  country_ends_with: String
  country_not_ends_with: String
  continent: String
  continent_not: String
  continent_in: [String!]
  continent_not_in: [String!]
  continent_lt: String
  continent_lte: String
  continent_gt: String
  continent_gte: String
  continent_contains: String
  continent_not_contains: String
  continent_starts_with: String
  continent_not_starts_with: String
  continent_ends_with: String
  continent_not_ends_with: String
  planet: String
  planet_not: String
  planet_in: [String!]
  planet_not_in: [String!]
  planet_lt: String
  planet_lte: String
  planet_gt: String
  planet_gte: String
  planet_contains: String
  planet_not_contains: String
  planet_starts_with: String
  planet_not_starts_with: String
  planet_ends_with: String
  planet_not_ends_with: String
  latitude: Float
  latitude_not: Float
  latitude_in: [Float!]
  latitude_not_in: [Float!]
  latitude_lt: Float
  latitude_lte: Float
  latitude_gt: Float
  latitude_gte: Float
  longitude: Float
  longitude_not: Float
  longitude_in: [Float!]
  longitude_not_in: [Float!]
  longitude_lt: Float
  longitude_lte: Float
  longitude_gt: Float
  longitude_gte: Float
  radiusMeter: Float
  radiusMeter_not: Float
  radiusMeter_in: [Float!]
  radiusMeter_not_in: [Float!]
  radiusMeter_lt: Float
  radiusMeter_lte: Float
  radiusMeter_gt: Float
  radiusMeter_gte: Float
  tags_every: TagWhereInput
  tags_some: TagWhereInput
  tags_none: TagWhereInput
  visitorsCount: Int
  visitorsCount_not: Int
  visitorsCount_in: [Int!]
  visitorsCount_not_in: [Int!]
  visitorsCount_lt: Int
  visitorsCount_lte: Int
  visitorsCount_gt: Int
  visitorsCount_gte: Int
  AND: [LocationWhereInput!]
  OR: [LocationWhereInput!]
  NOT: [LocationWhereInput!]
}

input LocationWhereUniqueInput {
  id: ID
}

scalar Long

type Membership {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime
  parent: Membership
  member: Profile!
  isBlocked: Boolean!
  group: Group!
  groupPinned: Boolean!
  showHistory: Boolean!
  hasLeft: Boolean!
  hasJoined: Boolean!
}

type MembershipConnection {
  pageInfo: PageInfo!
  edges: [MembershipEdge]!
  aggregate: AggregateMembership!
}

input MembershipCreateInput {
  id: ID
  parent: MembershipCreateOneInput
  member: ProfileCreateOneWithoutMembershipsInput!
  isBlocked: Boolean!
  group: GroupCreateOneWithoutMembersInput!
  groupPinned: Boolean!
  showHistory: Boolean!
  hasLeft: Boolean!
  hasJoined: Boolean!
}

input MembershipCreateManyWithoutGroupInput {
  create: [MembershipCreateWithoutGroupInput!]
  connect: [MembershipWhereUniqueInput!]
}

input MembershipCreateManyWithoutMemberInput {
  create: [MembershipCreateWithoutMemberInput!]
  connect: [MembershipWhereUniqueInput!]
}

input MembershipCreateOneInput {
  create: MembershipCreateInput
  connect: MembershipWhereUniqueInput
}

input MembershipCreateWithoutGroupInput {
  id: ID
  parent: MembershipCreateOneInput
  member: ProfileCreateOneWithoutMembershipsInput!
  isBlocked: Boolean!
  groupPinned: Boolean!
  showHistory: Boolean!
  hasLeft: Boolean!
  hasJoined: Boolean!
}

input MembershipCreateWithoutMemberInput {
  id: ID
  parent: MembershipCreateOneInput
  isBlocked: Boolean!
  group: GroupCreateOneWithoutMembersInput!
  groupPinned: Boolean!
  showHistory: Boolean!
  hasLeft: Boolean!
  hasJoined: Boolean!
}

type MembershipEdge {
  node: Membership!
  cursor: String!
}

enum MembershipOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  isBlocked_ASC
  isBlocked_DESC
  groupPinned_ASC
  groupPinned_DESC
  showHistory_ASC
  showHistory_DESC
  hasLeft_ASC
  hasLeft_DESC
  hasJoined_ASC
  hasJoined_DESC
}

type MembershipPreviousValues {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime
  isBlocked: Boolean!
  groupPinned: Boolean!
  showHistory: Boolean!
  hasLeft: Boolean!
  hasJoined: Boolean!
}

input MembershipScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  isBlocked: Boolean
  isBlocked_not: Boolean
  groupPinned: Boolean
  groupPinned_not: Boolean
  showHistory: Boolean
  showHistory_not: Boolean
  hasLeft: Boolean
  hasLeft_not: Boolean
  hasJoined: Boolean
  hasJoined_not: Boolean
  AND: [MembershipScalarWhereInput!]
  OR: [MembershipScalarWhereInput!]
  NOT: [MembershipScalarWhereInput!]
}

type MembershipSubscriptionPayload {
  mutation: MutationType!
  node: Membership
  updatedFields: [String!]
  previousValues: MembershipPreviousValues
}

input MembershipSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: MembershipWhereInput
  AND: [MembershipSubscriptionWhereInput!]
  OR: [MembershipSubscriptionWhereInput!]
  NOT: [MembershipSubscriptionWhereInput!]
}

input MembershipUpdateDataInput {
  parent: MembershipUpdateOneInput
  member: ProfileUpdateOneRequiredWithoutMembershipsInput
  isBlocked: Boolean
  group: GroupUpdateOneRequiredWithoutMembersInput
  groupPinned: Boolean
  showHistory: Boolean
  hasLeft: Boolean
  hasJoined: Boolean
}

input MembershipUpdateInput {
  parent: MembershipUpdateOneInput
  member: ProfileUpdateOneRequiredWithoutMembershipsInput
  isBlocked: Boolean
  group: GroupUpdateOneRequiredWithoutMembersInput
  groupPinned: Boolean
  showHistory: Boolean
  hasLeft: Boolean
  hasJoined: Boolean
}

input MembershipUpdateManyDataInput {
  isBlocked: Boolean
  groupPinned: Boolean
  showHistory: Boolean
  hasLeft: Boolean
  hasJoined: Boolean
}

input MembershipUpdateManyMutationInput {
  isBlocked: Boolean
  groupPinned: Boolean
  showHistory: Boolean
  hasLeft: Boolean
  hasJoined: Boolean
}

input MembershipUpdateManyWithoutGroupInput {
  create: [MembershipCreateWithoutGroupInput!]
  delete: [MembershipWhereUniqueInput!]
  connect: [MembershipWhereUniqueInput!]
  set: [MembershipWhereUniqueInput!]
  disconnect: [MembershipWhereUniqueInput!]
  update: [MembershipUpdateWithWhereUniqueWithoutGroupInput!]
  upsert: [MembershipUpsertWithWhereUniqueWithoutGroupInput!]
  deleteMany: [MembershipScalarWhereInput!]
  updateMany: [MembershipUpdateManyWithWhereNestedInput!]
}

input MembershipUpdateManyWithoutMemberInput {
  create: [MembershipCreateWithoutMemberInput!]
  delete: [MembershipWhereUniqueInput!]
  connect: [MembershipWhereUniqueInput!]
  set: [MembershipWhereUniqueInput!]
  disconnect: [MembershipWhereUniqueInput!]
  update: [MembershipUpdateWithWhereUniqueWithoutMemberInput!]
  upsert: [MembershipUpsertWithWhereUniqueWithoutMemberInput!]
  deleteMany: [MembershipScalarWhereInput!]
  updateMany: [MembershipUpdateManyWithWhereNestedInput!]
}

input MembershipUpdateManyWithWhereNestedInput {
  where: MembershipScalarWhereInput!
  data: MembershipUpdateManyDataInput!
}

input MembershipUpdateOneInput {
  create: MembershipCreateInput
  update: MembershipUpdateDataInput
  upsert: MembershipUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: MembershipWhereUniqueInput
}

input MembershipUpdateWithoutGroupDataInput {
  parent: MembershipUpdateOneInput
  member: ProfileUpdateOneRequiredWithoutMembershipsInput
  isBlocked: Boolean
  groupPinned: Boolean
  showHistory: Boolean
  hasLeft: Boolean
  hasJoined: Boolean
}

input MembershipUpdateWithoutMemberDataInput {
  parent: MembershipUpdateOneInput
  isBlocked: Boolean
  group: GroupUpdateOneRequiredWithoutMembersInput
  groupPinned: Boolean
  showHistory: Boolean
  hasLeft: Boolean
  hasJoined: Boolean
}

input MembershipUpdateWithWhereUniqueWithoutGroupInput {
  where: MembershipWhereUniqueInput!
  data: MembershipUpdateWithoutGroupDataInput!
}

input MembershipUpdateWithWhereUniqueWithoutMemberInput {
  where: MembershipWhereUniqueInput!
  data: MembershipUpdateWithoutMemberDataInput!
}

input MembershipUpsertNestedInput {
  update: MembershipUpdateDataInput!
  create: MembershipCreateInput!
}

input MembershipUpsertWithWhereUniqueWithoutGroupInput {
  where: MembershipWhereUniqueInput!
  update: MembershipUpdateWithoutGroupDataInput!
  create: MembershipCreateWithoutGroupInput!
}

input MembershipUpsertWithWhereUniqueWithoutMemberInput {
  where: MembershipWhereUniqueInput!
  update: MembershipUpdateWithoutMemberDataInput!
  create: MembershipCreateWithoutMemberInput!
}

input MembershipWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  parent: MembershipWhereInput
  member: ProfileWhereInput
  isBlocked: Boolean
  isBlocked_not: Boolean
  group: GroupWhereInput
  groupPinned: Boolean
  groupPinned_not: Boolean
  showHistory: Boolean
  showHistory_not: Boolean
  hasLeft: Boolean
  hasLeft_not: Boolean
  hasJoined: Boolean
  hasJoined_not: Boolean
  AND: [MembershipWhereInput!]
  OR: [MembershipWhereInput!]
  NOT: [MembershipWhereInput!]
}

input MembershipWhereUniqueInput {
  id: ID
}

type Mutation {
  createEvent(data: EventCreateInput!): Event!
  updateEvent(data: EventUpdateInput!, where: EventWhereUniqueInput!): Event
  updateManyEvents(data: EventUpdateManyMutationInput!, where: EventWhereInput): BatchPayload!
  upsertEvent(where: EventWhereUniqueInput!, create: EventCreateInput!, update: EventUpdateInput!): Event!
  deleteEvent(where: EventWhereUniqueInput!): Event
  deleteManyEvents(where: EventWhereInput): BatchPayload!
  createGroup(data: GroupCreateInput!): Group!
  updateGroup(data: GroupUpdateInput!, where: GroupWhereUniqueInput!): Group
  updateManyGroups(data: GroupUpdateManyMutationInput!, where: GroupWhereInput): BatchPayload!
  upsertGroup(where: GroupWhereUniqueInput!, create: GroupCreateInput!, update: GroupUpdateInput!): Group!
  deleteGroup(where: GroupWhereUniqueInput!): Group
  deleteManyGroups(where: GroupWhereInput): BatchPayload!
  createLocation(data: LocationCreateInput!): Location!
  updateLocation(data: LocationUpdateInput!, where: LocationWhereUniqueInput!): Location
  updateManyLocations(data: LocationUpdateManyMutationInput!, where: LocationWhereInput): BatchPayload!
  upsertLocation(where: LocationWhereUniqueInput!, create: LocationCreateInput!, update: LocationUpdateInput!): Location!
  deleteLocation(where: LocationWhereUniqueInput!): Location
  deleteManyLocations(where: LocationWhereInput): BatchPayload!
  createMembership(data: MembershipCreateInput!): Membership!
  updateMembership(data: MembershipUpdateInput!, where: MembershipWhereUniqueInput!): Membership
  updateManyMemberships(data: MembershipUpdateManyMutationInput!, where: MembershipWhereInput): BatchPayload!
  upsertMembership(where: MembershipWhereUniqueInput!, create: MembershipCreateInput!, update: MembershipUpdateInput!): Membership!
  deleteMembership(where: MembershipWhereUniqueInput!): Membership
  deleteManyMemberships(where: MembershipWhereInput): BatchPayload!
  createProfile(data: ProfileCreateInput!): Profile!
  updateProfile(data: ProfileUpdateInput!, where: ProfileWhereUniqueInput!): Profile
  updateManyProfiles(data: ProfileUpdateManyMutationInput!, where: ProfileWhereInput): BatchPayload!
  upsertProfile(where: ProfileWhereUniqueInput!, create: ProfileCreateInput!, update: ProfileUpdateInput!): Profile!
  deleteProfile(where: ProfileWhereUniqueInput!): Profile
  deleteManyProfiles(where: ProfileWhereInput): BatchPayload!
  createSession(data: SessionCreateInput!): Session!
  updateSession(data: SessionUpdateInput!, where: SessionWhereUniqueInput!): Session
  updateManySessions(data: SessionUpdateManyMutationInput!, where: SessionWhereInput): BatchPayload!
  upsertSession(where: SessionWhereUniqueInput!, create: SessionCreateInput!, update: SessionUpdateInput!): Session!
  deleteSession(where: SessionWhereUniqueInput!): Session
  deleteManySessions(where: SessionWhereInput): BatchPayload!
  createTag(data: TagCreateInput!): Tag!
  updateTag(data: TagUpdateInput!, where: TagWhereUniqueInput!): Tag
  updateManyTags(data: TagUpdateManyMutationInput!, where: TagWhereInput): BatchPayload!
  upsertTag(where: TagWhereUniqueInput!, create: TagCreateInput!, update: TagUpdateInput!): Tag!
  deleteTag(where: TagWhereUniqueInput!): Tag
  deleteManyTags(where: TagWhereInput): BatchPayload!
  createUser(data: UserCreateInput!): User!
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  updateManyUsers(data: UserUpdateManyMutationInput!, where: UserWhereInput): BatchPayload!
  upsertUser(where: UserWhereUniqueInput!, create: UserCreateInput!, update: UserUpdateInput!): User!
  deleteUser(where: UserWhereUniqueInput!): User
  deleteManyUsers(where: UserWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Profile {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime
  creator: User!
  name: String!
  timezone: String
  status: StatusType!
  type: ProfileType!
  isHidden: Boolean!
  isBot: Boolean!
  slogan: String
  pictureAvatar: String!
  pictureBanner: String
  memberships(where: MembershipWhereInput, orderBy: MembershipOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Membership!]
}

type ProfileConnection {
  pageInfo: PageInfo!
  edges: [ProfileEdge]!
  aggregate: AggregateProfile!
}

input ProfileCreateInput {
  id: ID
  creator: UserCreateOneWithoutProfilesInput!
  name: String!
  timezone: String
  status: StatusType!
  type: ProfileType!
  isHidden: Boolean!
  isBot: Boolean!
  slogan: String
  pictureAvatar: String!
  pictureBanner: String
  memberships: MembershipCreateManyWithoutMemberInput
}

input ProfileCreateManyWithoutCreatorInput {
  create: [ProfileCreateWithoutCreatorInput!]
  connect: [ProfileWhereUniqueInput!]
}

input ProfileCreateOneInput {
  create: ProfileCreateInput
  connect: ProfileWhereUniqueInput
}

input ProfileCreateOneWithoutMembershipsInput {
  create: ProfileCreateWithoutMembershipsInput
  connect: ProfileWhereUniqueInput
}

input ProfileCreateWithoutCreatorInput {
  id: ID
  name: String!
  timezone: String
  status: StatusType!
  type: ProfileType!
  isHidden: Boolean!
  isBot: Boolean!
  slogan: String
  pictureAvatar: String!
  pictureBanner: String
  memberships: MembershipCreateManyWithoutMemberInput
}

input ProfileCreateWithoutMembershipsInput {
  id: ID
  creator: UserCreateOneWithoutProfilesInput!
  name: String!
  timezone: String
  status: StatusType!
  type: ProfileType!
  isHidden: Boolean!
  isBot: Boolean!
  slogan: String
  pictureAvatar: String!
  pictureBanner: String
}

type ProfileEdge {
  node: Profile!
  cursor: String!
}

enum ProfileOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  name_ASC
  name_DESC
  timezone_ASC
  timezone_DESC
  status_ASC
  status_DESC
  type_ASC
  type_DESC
  isHidden_ASC
  isHidden_DESC
  isBot_ASC
  isBot_DESC
  slogan_ASC
  slogan_DESC
  pictureAvatar_ASC
  pictureAvatar_DESC
  pictureBanner_ASC
  pictureBanner_DESC
}

type ProfilePreviousValues {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime
  name: String!
  timezone: String
  status: StatusType!
  type: ProfileType!
  isHidden: Boolean!
  isBot: Boolean!
  slogan: String
  pictureAvatar: String!
  pictureBanner: String
}

input ProfileScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  timezone: String
  timezone_not: String
  timezone_in: [String!]
  timezone_not_in: [String!]
  timezone_lt: String
  timezone_lte: String
  timezone_gt: String
  timezone_gte: String
  timezone_contains: String
  timezone_not_contains: String
  timezone_starts_with: String
  timezone_not_starts_with: String
  timezone_ends_with: String
  timezone_not_ends_with: String
  status: StatusType
  status_not: StatusType
  status_in: [StatusType!]
  status_not_in: [StatusType!]
  type: ProfileType
  type_not: ProfileType
  type_in: [ProfileType!]
  type_not_in: [ProfileType!]
  isHidden: Boolean
  isHidden_not: Boolean
  isBot: Boolean
  isBot_not: Boolean
  slogan: String
  slogan_not: String
  slogan_in: [String!]
  slogan_not_in: [String!]
  slogan_lt: String
  slogan_lte: String
  slogan_gt: String
  slogan_gte: String
  slogan_contains: String
  slogan_not_contains: String
  slogan_starts_with: String
  slogan_not_starts_with: String
  slogan_ends_with: String
  slogan_not_ends_with: String
  pictureAvatar: String
  pictureAvatar_not: String
  pictureAvatar_in: [String!]
  pictureAvatar_not_in: [String!]
  pictureAvatar_lt: String
  pictureAvatar_lte: String
  pictureAvatar_gt: String
  pictureAvatar_gte: String
  pictureAvatar_contains: String
  pictureAvatar_not_contains: String
  pictureAvatar_starts_with: String
  pictureAvatar_not_starts_with: String
  pictureAvatar_ends_with: String
  pictureAvatar_not_ends_with: String
  pictureBanner: String
  pictureBanner_not: String
  pictureBanner_in: [String!]
  pictureBanner_not_in: [String!]
  pictureBanner_lt: String
  pictureBanner_lte: String
  pictureBanner_gt: String
  pictureBanner_gte: String
  pictureBanner_contains: String
  pictureBanner_not_contains: String
  pictureBanner_starts_with: String
  pictureBanner_not_starts_with: String
  pictureBanner_ends_with: String
  pictureBanner_not_ends_with: String
  AND: [ProfileScalarWhereInput!]
  OR: [ProfileScalarWhereInput!]
  NOT: [ProfileScalarWhereInput!]
}

type ProfileSubscriptionPayload {
  mutation: MutationType!
  node: Profile
  updatedFields: [String!]
  previousValues: ProfilePreviousValues
}

input ProfileSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ProfileWhereInput
  AND: [ProfileSubscriptionWhereInput!]
  OR: [ProfileSubscriptionWhereInput!]
  NOT: [ProfileSubscriptionWhereInput!]
}

enum ProfileType {
  WORK
  PRIVATE
}

input ProfileUpdateDataInput {
  creator: UserUpdateOneRequiredWithoutProfilesInput
  name: String
  timezone: String
  status: StatusType
  type: ProfileType
  isHidden: Boolean
  isBot: Boolean
  slogan: String
  pictureAvatar: String
  pictureBanner: String
  memberships: MembershipUpdateManyWithoutMemberInput
}

input ProfileUpdateInput {
  creator: UserUpdateOneRequiredWithoutProfilesInput
  name: String
  timezone: String
  status: StatusType
  type: ProfileType
  isHidden: Boolean
  isBot: Boolean
  slogan: String
  pictureAvatar: String
  pictureBanner: String
  memberships: MembershipUpdateManyWithoutMemberInput
}

input ProfileUpdateManyDataInput {
  name: String
  timezone: String
  status: StatusType
  type: ProfileType
  isHidden: Boolean
  isBot: Boolean
  slogan: String
  pictureAvatar: String
  pictureBanner: String
}

input ProfileUpdateManyMutationInput {
  name: String
  timezone: String
  status: StatusType
  type: ProfileType
  isHidden: Boolean
  isBot: Boolean
  slogan: String
  pictureAvatar: String
  pictureBanner: String
}

input ProfileUpdateManyWithoutCreatorInput {
  create: [ProfileCreateWithoutCreatorInput!]
  delete: [ProfileWhereUniqueInput!]
  connect: [ProfileWhereUniqueInput!]
  set: [ProfileWhereUniqueInput!]
  disconnect: [ProfileWhereUniqueInput!]
  update: [ProfileUpdateWithWhereUniqueWithoutCreatorInput!]
  upsert: [ProfileUpsertWithWhereUniqueWithoutCreatorInput!]
  deleteMany: [ProfileScalarWhereInput!]
  updateMany: [ProfileUpdateManyWithWhereNestedInput!]
}

input ProfileUpdateManyWithWhereNestedInput {
  where: ProfileScalarWhereInput!
  data: ProfileUpdateManyDataInput!
}

input ProfileUpdateOneRequiredInput {
  create: ProfileCreateInput
  update: ProfileUpdateDataInput
  upsert: ProfileUpsertNestedInput
  connect: ProfileWhereUniqueInput
}

input ProfileUpdateOneRequiredWithoutMembershipsInput {
  create: ProfileCreateWithoutMembershipsInput
  update: ProfileUpdateWithoutMembershipsDataInput
  upsert: ProfileUpsertWithoutMembershipsInput
  connect: ProfileWhereUniqueInput
}

input ProfileUpdateWithoutCreatorDataInput {
  name: String
  timezone: String
  status: StatusType
  type: ProfileType
  isHidden: Boolean
  isBot: Boolean
  slogan: String
  pictureAvatar: String
  pictureBanner: String
  memberships: MembershipUpdateManyWithoutMemberInput
}

input ProfileUpdateWithoutMembershipsDataInput {
  creator: UserUpdateOneRequiredWithoutProfilesInput
  name: String
  timezone: String
  status: StatusType
  type: ProfileType
  isHidden: Boolean
  isBot: Boolean
  slogan: String
  pictureAvatar: String
  pictureBanner: String
}

input ProfileUpdateWithWhereUniqueWithoutCreatorInput {
  where: ProfileWhereUniqueInput!
  data: ProfileUpdateWithoutCreatorDataInput!
}

input ProfileUpsertNestedInput {
  update: ProfileUpdateDataInput!
  create: ProfileCreateInput!
}

input ProfileUpsertWithoutMembershipsInput {
  update: ProfileUpdateWithoutMembershipsDataInput!
  create: ProfileCreateWithoutMembershipsInput!
}

input ProfileUpsertWithWhereUniqueWithoutCreatorInput {
  where: ProfileWhereUniqueInput!
  update: ProfileUpdateWithoutCreatorDataInput!
  create: ProfileCreateWithoutCreatorInput!
}

input ProfileWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  creator: UserWhereInput
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  timezone: String
  timezone_not: String
  timezone_in: [String!]
  timezone_not_in: [String!]
  timezone_lt: String
  timezone_lte: String
  timezone_gt: String
  timezone_gte: String
  timezone_contains: String
  timezone_not_contains: String
  timezone_starts_with: String
  timezone_not_starts_with: String
  timezone_ends_with: String
  timezone_not_ends_with: String
  status: StatusType
  status_not: StatusType
  status_in: [StatusType!]
  status_not_in: [StatusType!]
  type: ProfileType
  type_not: ProfileType
  type_in: [ProfileType!]
  type_not_in: [ProfileType!]
  isHidden: Boolean
  isHidden_not: Boolean
  isBot: Boolean
  isBot_not: Boolean
  slogan: String
  slogan_not: String
  slogan_in: [String!]
  slogan_not_in: [String!]
  slogan_lt: String
  slogan_lte: String
  slogan_gt: String
  slogan_gte: String
  slogan_contains: String
  slogan_not_contains: String
  slogan_starts_with: String
  slogan_not_starts_with: String
  slogan_ends_with: String
  slogan_not_ends_with: String
  pictureAvatar: String
  pictureAvatar_not: String
  pictureAvatar_in: [String!]
  pictureAvatar_not_in: [String!]
  pictureAvatar_lt: String
  pictureAvatar_lte: String
  pictureAvatar_gt: String
  pictureAvatar_gte: String
  pictureAvatar_contains: String
  pictureAvatar_not_contains: String
  pictureAvatar_starts_with: String
  pictureAvatar_not_starts_with: String
  pictureAvatar_ends_with: String
  pictureAvatar_not_ends_with: String
  pictureBanner: String
  pictureBanner_not: String
  pictureBanner_in: [String!]
  pictureBanner_not_in: [String!]
  pictureBanner_lt: String
  pictureBanner_lte: String
  pictureBanner_gt: String
  pictureBanner_gte: String
  pictureBanner_contains: String
  pictureBanner_not_contains: String
  pictureBanner_starts_with: String
  pictureBanner_not_starts_with: String
  pictureBanner_ends_with: String
  pictureBanner_not_ends_with: String
  memberships_every: MembershipWhereInput
  memberships_some: MembershipWhereInput
  memberships_none: MembershipWhereInput
  AND: [ProfileWhereInput!]
  OR: [ProfileWhereInput!]
  NOT: [ProfileWhereInput!]
}

input ProfileWhereUniqueInput {
  id: ID
}

type Query {
  event(where: EventWhereUniqueInput!): Event
  events(where: EventWhereInput, orderBy: EventOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Event]!
  eventsConnection(where: EventWhereInput, orderBy: EventOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): EventConnection!
  group(where: GroupWhereUniqueInput!): Group
  groups(where: GroupWhereInput, orderBy: GroupOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Group]!
  groupsConnection(where: GroupWhereInput, orderBy: GroupOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): GroupConnection!
  location(where: LocationWhereUniqueInput!): Location
  locations(where: LocationWhereInput, orderBy: LocationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Location]!
  locationsConnection(where: LocationWhereInput, orderBy: LocationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): LocationConnection!
  membership(where: MembershipWhereUniqueInput!): Membership
  memberships(where: MembershipWhereInput, orderBy: MembershipOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Membership]!
  membershipsConnection(where: MembershipWhereInput, orderBy: MembershipOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): MembershipConnection!
  profile(where: ProfileWhereUniqueInput!): Profile
  profiles(where: ProfileWhereInput, orderBy: ProfileOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Profile]!
  profilesConnection(where: ProfileWhereInput, orderBy: ProfileOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ProfileConnection!
  session(where: SessionWhereUniqueInput!): Session
  sessions(where: SessionWhereInput, orderBy: SessionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Session]!
  sessionsConnection(where: SessionWhereInput, orderBy: SessionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): SessionConnection!
  tag(where: TagWhereUniqueInput!): Tag
  tags(where: TagWhereInput, orderBy: TagOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Tag]!
  tagsConnection(where: TagWhereInput, orderBy: TagOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): TagConnection!
  user(where: UserWhereUniqueInput!): User
  users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User]!
  usersConnection(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserConnection!
  node(id: ID!): Node
}

type Session {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime
  csrfToken: String!
  authToken: String!
  validTo: DateTime!
  timedOut: DateTime
  loggedOut: DateTime
  user: User!
  lastUsedProfile: Profile!
  location: Location
  lastIpAddress: String
}

type SessionConnection {
  pageInfo: PageInfo!
  edges: [SessionEdge]!
  aggregate: AggregateSession!
}

input SessionCreateInput {
  id: ID
  csrfToken: String!
  authToken: String!
  validTo: DateTime!
  timedOut: DateTime
  loggedOut: DateTime
  user: UserCreateOneWithoutSessionsInput!
  lastUsedProfile: ProfileCreateOneInput!
  location: LocationCreateOneInput
  lastIpAddress: String
}

input SessionCreateManyWithoutUserInput {
  create: [SessionCreateWithoutUserInput!]
  connect: [SessionWhereUniqueInput!]
}

input SessionCreateWithoutUserInput {
  id: ID
  csrfToken: String!
  authToken: String!
  validTo: DateTime!
  timedOut: DateTime
  loggedOut: DateTime
  lastUsedProfile: ProfileCreateOneInput!
  location: LocationCreateOneInput
  lastIpAddress: String
}

type SessionEdge {
  node: Session!
  cursor: String!
}

enum SessionOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  csrfToken_ASC
  csrfToken_DESC
  authToken_ASC
  authToken_DESC
  validTo_ASC
  validTo_DESC
  timedOut_ASC
  timedOut_DESC
  loggedOut_ASC
  loggedOut_DESC
  lastIpAddress_ASC
  lastIpAddress_DESC
}

type SessionPreviousValues {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime
  csrfToken: String!
  authToken: String!
  validTo: DateTime!
  timedOut: DateTime
  loggedOut: DateTime
  lastIpAddress: String
}

input SessionScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  csrfToken: String
  csrfToken_not: String
  csrfToken_in: [String!]
  csrfToken_not_in: [String!]
  csrfToken_lt: String
  csrfToken_lte: String
  csrfToken_gt: String
  csrfToken_gte: String
  csrfToken_contains: String
  csrfToken_not_contains: String
  csrfToken_starts_with: String
  csrfToken_not_starts_with: String
  csrfToken_ends_with: String
  csrfToken_not_ends_with: String
  authToken: String
  authToken_not: String
  authToken_in: [String!]
  authToken_not_in: [String!]
  authToken_lt: String
  authToken_lte: String
  authToken_gt: String
  authToken_gte: String
  authToken_contains: String
  authToken_not_contains: String
  authToken_starts_with: String
  authToken_not_starts_with: String
  authToken_ends_with: String
  authToken_not_ends_with: String
  validTo: DateTime
  validTo_not: DateTime
  validTo_in: [DateTime!]
  validTo_not_in: [DateTime!]
  validTo_lt: DateTime
  validTo_lte: DateTime
  validTo_gt: DateTime
  validTo_gte: DateTime
  timedOut: DateTime
  timedOut_not: DateTime
  timedOut_in: [DateTime!]
  timedOut_not_in: [DateTime!]
  timedOut_lt: DateTime
  timedOut_lte: DateTime
  timedOut_gt: DateTime
  timedOut_gte: DateTime
  loggedOut: DateTime
  loggedOut_not: DateTime
  loggedOut_in: [DateTime!]
  loggedOut_not_in: [DateTime!]
  loggedOut_lt: DateTime
  loggedOut_lte: DateTime
  loggedOut_gt: DateTime
  loggedOut_gte: DateTime
  lastIpAddress: String
  lastIpAddress_not: String
  lastIpAddress_in: [String!]
  lastIpAddress_not_in: [String!]
  lastIpAddress_lt: String
  lastIpAddress_lte: String
  lastIpAddress_gt: String
  lastIpAddress_gte: String
  lastIpAddress_contains: String
  lastIpAddress_not_contains: String
  lastIpAddress_starts_with: String
  lastIpAddress_not_starts_with: String
  lastIpAddress_ends_with: String
  lastIpAddress_not_ends_with: String
  AND: [SessionScalarWhereInput!]
  OR: [SessionScalarWhereInput!]
  NOT: [SessionScalarWhereInput!]
}

type SessionSubscriptionPayload {
  mutation: MutationType!
  node: Session
  updatedFields: [String!]
  previousValues: SessionPreviousValues
}

input SessionSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: SessionWhereInput
  AND: [SessionSubscriptionWhereInput!]
  OR: [SessionSubscriptionWhereInput!]
  NOT: [SessionSubscriptionWhereInput!]
}

input SessionUpdateInput {
  csrfToken: String
  authToken: String
  validTo: DateTime
  timedOut: DateTime
  loggedOut: DateTime
  user: UserUpdateOneRequiredWithoutSessionsInput
  lastUsedProfile: ProfileUpdateOneRequiredInput
  location: LocationUpdateOneInput
  lastIpAddress: String
}

input SessionUpdateManyDataInput {
  csrfToken: String
  authToken: String
  validTo: DateTime
  timedOut: DateTime
  loggedOut: DateTime
  lastIpAddress: String
}

input SessionUpdateManyMutationInput {
  csrfToken: String
  authToken: String
  validTo: DateTime
  timedOut: DateTime
  loggedOut: DateTime
  lastIpAddress: String
}

input SessionUpdateManyWithoutUserInput {
  create: [SessionCreateWithoutUserInput!]
  delete: [SessionWhereUniqueInput!]
  connect: [SessionWhereUniqueInput!]
  set: [SessionWhereUniqueInput!]
  disconnect: [SessionWhereUniqueInput!]
  update: [SessionUpdateWithWhereUniqueWithoutUserInput!]
  upsert: [SessionUpsertWithWhereUniqueWithoutUserInput!]
  deleteMany: [SessionScalarWhereInput!]
  updateMany: [SessionUpdateManyWithWhereNestedInput!]
}

input SessionUpdateManyWithWhereNestedInput {
  where: SessionScalarWhereInput!
  data: SessionUpdateManyDataInput!
}

input SessionUpdateWithoutUserDataInput {
  csrfToken: String
  authToken: String
  validTo: DateTime
  timedOut: DateTime
  loggedOut: DateTime
  lastUsedProfile: ProfileUpdateOneRequiredInput
  location: LocationUpdateOneInput
  lastIpAddress: String
}

input SessionUpdateWithWhereUniqueWithoutUserInput {
  where: SessionWhereUniqueInput!
  data: SessionUpdateWithoutUserDataInput!
}

input SessionUpsertWithWhereUniqueWithoutUserInput {
  where: SessionWhereUniqueInput!
  update: SessionUpdateWithoutUserDataInput!
  create: SessionCreateWithoutUserInput!
}

input SessionWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  csrfToken: String
  csrfToken_not: String
  csrfToken_in: [String!]
  csrfToken_not_in: [String!]
  csrfToken_lt: String
  csrfToken_lte: String
  csrfToken_gt: String
  csrfToken_gte: String
  csrfToken_contains: String
  csrfToken_not_contains: String
  csrfToken_starts_with: String
  csrfToken_not_starts_with: String
  csrfToken_ends_with: String
  csrfToken_not_ends_with: String
  authToken: String
  authToken_not: String
  authToken_in: [String!]
  authToken_not_in: [String!]
  authToken_lt: String
  authToken_lte: String
  authToken_gt: String
  authToken_gte: String
  authToken_contains: String
  authToken_not_contains: String
  authToken_starts_with: String
  authToken_not_starts_with: String
  authToken_ends_with: String
  authToken_not_ends_with: String
  validTo: DateTime
  validTo_not: DateTime
  validTo_in: [DateTime!]
  validTo_not_in: [DateTime!]
  validTo_lt: DateTime
  validTo_lte: DateTime
  validTo_gt: DateTime
  validTo_gte: DateTime
  timedOut: DateTime
  timedOut_not: DateTime
  timedOut_in: [DateTime!]
  timedOut_not_in: [DateTime!]
  timedOut_lt: DateTime
  timedOut_lte: DateTime
  timedOut_gt: DateTime
  timedOut_gte: DateTime
  loggedOut: DateTime
  loggedOut_not: DateTime
  loggedOut_in: [DateTime!]
  loggedOut_not_in: [DateTime!]
  loggedOut_lt: DateTime
  loggedOut_lte: DateTime
  loggedOut_gt: DateTime
  loggedOut_gte: DateTime
  user: UserWhereInput
  lastUsedProfile: ProfileWhereInput
  location: LocationWhereInput
  lastIpAddress: String
  lastIpAddress_not: String
  lastIpAddress_in: [String!]
  lastIpAddress_not_in: [String!]
  lastIpAddress_lt: String
  lastIpAddress_lte: String
  lastIpAddress_gt: String
  lastIpAddress_gte: String
  lastIpAddress_contains: String
  lastIpAddress_not_contains: String
  lastIpAddress_starts_with: String
  lastIpAddress_not_starts_with: String
  lastIpAddress_ends_with: String
  lastIpAddress_not_ends_with: String
  AND: [SessionWhereInput!]
  OR: [SessionWhereInput!]
  NOT: [SessionWhereInput!]
}

input SessionWhereUniqueInput {
  id: ID
  csrfToken: String
  authToken: String
}

enum StatusType {
  BUSY
  OFFLINE
  ONLINE
  AWAY
}

type Subscription {
  event(where: EventSubscriptionWhereInput): EventSubscriptionPayload
  group(where: GroupSubscriptionWhereInput): GroupSubscriptionPayload
  location(where: LocationSubscriptionWhereInput): LocationSubscriptionPayload
  membership(where: MembershipSubscriptionWhereInput): MembershipSubscriptionPayload
  profile(where: ProfileSubscriptionWhereInput): ProfileSubscriptionPayload
  session(where: SessionSubscriptionWhereInput): SessionSubscriptionPayload
  tag(where: TagSubscriptionWhereInput): TagSubscriptionPayload
  user(where: UserSubscriptionWhereInput): UserSubscriptionPayload
}

type Tag {
  id: ID!
  createdAt: DateTime!
  creator: Profile!
  name: String!
  parents(where: TagWhereInput, orderBy: TagOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Tag!]
}

type TagConnection {
  pageInfo: PageInfo!
  edges: [TagEdge]!
  aggregate: AggregateTag!
}

input TagCreateInput {
  id: ID
  creator: ProfileCreateOneInput!
  name: String!
  parents: TagCreateManyInput
}

input TagCreateManyInput {
  create: [TagCreateInput!]
  connect: [TagWhereUniqueInput!]
}

type TagEdge {
  node: Tag!
  cursor: String!
}

enum TagOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  name_ASC
  name_DESC
}

type TagPreviousValues {
  id: ID!
  createdAt: DateTime!
  name: String!
}

input TagScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  AND: [TagScalarWhereInput!]
  OR: [TagScalarWhereInput!]
  NOT: [TagScalarWhereInput!]
}

type TagSubscriptionPayload {
  mutation: MutationType!
  node: Tag
  updatedFields: [String!]
  previousValues: TagPreviousValues
}

input TagSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: TagWhereInput
  AND: [TagSubscriptionWhereInput!]
  OR: [TagSubscriptionWhereInput!]
  NOT: [TagSubscriptionWhereInput!]
}

input TagUpdateDataInput {
  creator: ProfileUpdateOneRequiredInput
  name: String
  parents: TagUpdateManyInput
}

input TagUpdateInput {
  creator: ProfileUpdateOneRequiredInput
  name: String
  parents: TagUpdateManyInput
}

input TagUpdateManyDataInput {
  name: String
}

input TagUpdateManyInput {
  create: [TagCreateInput!]
  update: [TagUpdateWithWhereUniqueNestedInput!]
  upsert: [TagUpsertWithWhereUniqueNestedInput!]
  delete: [TagWhereUniqueInput!]
  connect: [TagWhereUniqueInput!]
  set: [TagWhereUniqueInput!]
  disconnect: [TagWhereUniqueInput!]
  deleteMany: [TagScalarWhereInput!]
  updateMany: [TagUpdateManyWithWhereNestedInput!]
}

input TagUpdateManyMutationInput {
  name: String
}

input TagUpdateManyWithWhereNestedInput {
  where: TagScalarWhereInput!
  data: TagUpdateManyDataInput!
}

input TagUpdateWithWhereUniqueNestedInput {
  where: TagWhereUniqueInput!
  data: TagUpdateDataInput!
}

input TagUpsertWithWhereUniqueNestedInput {
  where: TagWhereUniqueInput!
  update: TagUpdateDataInput!
  create: TagCreateInput!
}

input TagWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  creator: ProfileWhereInput
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  parents_every: TagWhereInput
  parents_some: TagWhereInput
  parents_none: TagWhereInput
  AND: [TagWhereInput!]
  OR: [TagWhereInput!]
  NOT: [TagWhereInput!]
}

input TagWhereUniqueInput {
  id: ID
}

type User {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime
  parent: User
  firstName: String!
  lastName: String!
  timezone: String!
  email: String!
  mobilePhone: String
  passwordSalt: String!
  passwordHash: String!
  isVerified: Boolean!
  challenge: String
  profiles(where: ProfileWhereInput, orderBy: ProfileOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Profile!]
  sessions(where: SessionWhereInput, orderBy: SessionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Session!]
}

type UserConnection {
  pageInfo: PageInfo!
  edges: [UserEdge]!
  aggregate: AggregateUser!
}

input UserCreateInput {
  id: ID
  parent: UserCreateOneInput
  firstName: String!
  lastName: String!
  timezone: String!
  email: String!
  mobilePhone: String
  passwordSalt: String!
  passwordHash: String!
  isVerified: Boolean!
  challenge: String
  profiles: ProfileCreateManyWithoutCreatorInput
  sessions: SessionCreateManyWithoutUserInput
}

input UserCreateOneInput {
  create: UserCreateInput
  connect: UserWhereUniqueInput
}

input UserCreateOneWithoutProfilesInput {
  create: UserCreateWithoutProfilesInput
  connect: UserWhereUniqueInput
}

input UserCreateOneWithoutSessionsInput {
  create: UserCreateWithoutSessionsInput
  connect: UserWhereUniqueInput
}

input UserCreateWithoutProfilesInput {
  id: ID
  parent: UserCreateOneInput
  firstName: String!
  lastName: String!
  timezone: String!
  email: String!
  mobilePhone: String
  passwordSalt: String!
  passwordHash: String!
  isVerified: Boolean!
  challenge: String
  sessions: SessionCreateManyWithoutUserInput
}

input UserCreateWithoutSessionsInput {
  id: ID
  parent: UserCreateOneInput
  firstName: String!
  lastName: String!
  timezone: String!
  email: String!
  mobilePhone: String
  passwordSalt: String!
  passwordHash: String!
  isVerified: Boolean!
  challenge: String
  profiles: ProfileCreateManyWithoutCreatorInput
}

type UserEdge {
  node: User!
  cursor: String!
}

enum UserOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  firstName_ASC
  firstName_DESC
  lastName_ASC
  lastName_DESC
  timezone_ASC
  timezone_DESC
  email_ASC
  email_DESC
  mobilePhone_ASC
  mobilePhone_DESC
  passwordSalt_ASC
  passwordSalt_DESC
  passwordHash_ASC
  passwordHash_DESC
  isVerified_ASC
  isVerified_DESC
  challenge_ASC
  challenge_DESC
}

type UserPreviousValues {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime
  firstName: String!
  lastName: String!
  timezone: String!
  email: String!
  mobilePhone: String
  passwordSalt: String!
  passwordHash: String!
  isVerified: Boolean!
  challenge: String
}

type UserSubscriptionPayload {
  mutation: MutationType!
  node: User
  updatedFields: [String!]
  previousValues: UserPreviousValues
}

input UserSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UserWhereInput
  AND: [UserSubscriptionWhereInput!]
  OR: [UserSubscriptionWhereInput!]
  NOT: [UserSubscriptionWhereInput!]
}

input UserUpdateDataInput {
  parent: UserUpdateOneInput
  firstName: String
  lastName: String
  timezone: String
  email: String
  mobilePhone: String
  passwordSalt: String
  passwordHash: String
  isVerified: Boolean
  challenge: String
  profiles: ProfileUpdateManyWithoutCreatorInput
  sessions: SessionUpdateManyWithoutUserInput
}

input UserUpdateInput {
  parent: UserUpdateOneInput
  firstName: String
  lastName: String
  timezone: String
  email: String
  mobilePhone: String
  passwordSalt: String
  passwordHash: String
  isVerified: Boolean
  challenge: String
  profiles: ProfileUpdateManyWithoutCreatorInput
  sessions: SessionUpdateManyWithoutUserInput
}

input UserUpdateManyMutationInput {
  firstName: String
  lastName: String
  timezone: String
  email: String
  mobilePhone: String
  passwordSalt: String
  passwordHash: String
  isVerified: Boolean
  challenge: String
}

input UserUpdateOneInput {
  create: UserCreateInput
  update: UserUpdateDataInput
  upsert: UserUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: UserWhereUniqueInput
}

input UserUpdateOneRequiredWithoutProfilesInput {
  create: UserCreateWithoutProfilesInput
  update: UserUpdateWithoutProfilesDataInput
  upsert: UserUpsertWithoutProfilesInput
  connect: UserWhereUniqueInput
}

input UserUpdateOneRequiredWithoutSessionsInput {
  create: UserCreateWithoutSessionsInput
  update: UserUpdateWithoutSessionsDataInput
  upsert: UserUpsertWithoutSessionsInput
  connect: UserWhereUniqueInput
}

input UserUpdateWithoutProfilesDataInput {
  parent: UserUpdateOneInput
  firstName: String
  lastName: String
  timezone: String
  email: String
  mobilePhone: String
  passwordSalt: String
  passwordHash: String
  isVerified: Boolean
  challenge: String
  sessions: SessionUpdateManyWithoutUserInput
}

input UserUpdateWithoutSessionsDataInput {
  parent: UserUpdateOneInput
  firstName: String
  lastName: String
  timezone: String
  email: String
  mobilePhone: String
  passwordSalt: String
  passwordHash: String
  isVerified: Boolean
  challenge: String
  profiles: ProfileUpdateManyWithoutCreatorInput
}

input UserUpsertNestedInput {
  update: UserUpdateDataInput!
  create: UserCreateInput!
}

input UserUpsertWithoutProfilesInput {
  update: UserUpdateWithoutProfilesDataInput!
  create: UserCreateWithoutProfilesInput!
}

input UserUpsertWithoutSessionsInput {
  update: UserUpdateWithoutSessionsDataInput!
  create: UserCreateWithoutSessionsInput!
}

input UserWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  parent: UserWhereInput
  firstName: String
  firstName_not: String
  firstName_in: [String!]
  firstName_not_in: [String!]
  firstName_lt: String
  firstName_lte: String
  firstName_gt: String
  firstName_gte: String
  firstName_contains: String
  firstName_not_contains: String
  firstName_starts_with: String
  firstName_not_starts_with: String
  firstName_ends_with: String
  firstName_not_ends_with: String
  lastName: String
  lastName_not: String
  lastName_in: [String!]
  lastName_not_in: [String!]
  lastName_lt: String
  lastName_lte: String
  lastName_gt: String
  lastName_gte: String
  lastName_contains: String
  lastName_not_contains: String
  lastName_starts_with: String
  lastName_not_starts_with: String
  lastName_ends_with: String
  lastName_not_ends_with: String
  timezone: String
  timezone_not: String
  timezone_in: [String!]
  timezone_not_in: [String!]
  timezone_lt: String
  timezone_lte: String
  timezone_gt: String
  timezone_gte: String
  timezone_contains: String
  timezone_not_contains: String
  timezone_starts_with: String
  timezone_not_starts_with: String
  timezone_ends_with: String
  timezone_not_ends_with: String
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  mobilePhone: String
  mobilePhone_not: String
  mobilePhone_in: [String!]
  mobilePhone_not_in: [String!]
  mobilePhone_lt: String
  mobilePhone_lte: String
  mobilePhone_gt: String
  mobilePhone_gte: String
  mobilePhone_contains: String
  mobilePhone_not_contains: String
  mobilePhone_starts_with: String
  mobilePhone_not_starts_with: String
  mobilePhone_ends_with: String
  mobilePhone_not_ends_with: String
  passwordSalt: String
  passwordSalt_not: String
  passwordSalt_in: [String!]
  passwordSalt_not_in: [String!]
  passwordSalt_lt: String
  passwordSalt_lte: String
  passwordSalt_gt: String
  passwordSalt_gte: String
  passwordSalt_contains: String
  passwordSalt_not_contains: String
  passwordSalt_starts_with: String
  passwordSalt_not_starts_with: String
  passwordSalt_ends_with: String
  passwordSalt_not_ends_with: String
  passwordHash: String
  passwordHash_not: String
  passwordHash_in: [String!]
  passwordHash_not_in: [String!]
  passwordHash_lt: String
  passwordHash_lte: String
  passwordHash_gt: String
  passwordHash_gte: String
  passwordHash_contains: String
  passwordHash_not_contains: String
  passwordHash_starts_with: String
  passwordHash_not_starts_with: String
  passwordHash_ends_with: String
  passwordHash_not_ends_with: String
  isVerified: Boolean
  isVerified_not: Boolean
  challenge: String
  challenge_not: String
  challenge_in: [String!]
  challenge_not_in: [String!]
  challenge_lt: String
  challenge_lte: String
  challenge_gt: String
  challenge_gte: String
  challenge_contains: String
  challenge_not_contains: String
  challenge_starts_with: String
  challenge_not_starts_with: String
  challenge_ends_with: String
  challenge_not_ends_with: String
  profiles_every: ProfileWhereInput
  profiles_some: ProfileWhereInput
  profiles_none: ProfileWhereInput
  sessions_every: SessionWhereInput
  sessions_some: SessionWhereInput
  sessions_none: SessionWhereInput
  AND: [UserWhereInput!]
  OR: [UserWhereInput!]
  NOT: [UserWhereInput!]
}

input UserWhereUniqueInput {
  id: ID
  email: String
}
`