// Code generated by Prisma (prisma@1.34.10). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

export const typeDefs = /* GraphQL */ `type AggregateAsset {
  count: Int!
}

type AggregateAttachment {
  count: Int!
}

type AggregateExchange {
  count: Int!
}

type AggregateGroup {
  count: Int!
}

type AggregateLocation {
  count: Int!
}

type AggregateMembership {
  count: Int!
}

type AggregateMessage {
  count: Int!
}

type AggregatePortfolio {
  count: Int!
}

type AggregateProfile {
  count: Int!
}

type AggregateReaction {
  count: Int!
}

type AggregateSession {
  count: Int!
}

type AggregateTransaction {
  count: Int!
}

type AggregateUser {
  count: Int!
}

type Asset {
  id: ID!
  name: String!
}

type AssetConnection {
  pageInfo: PageInfo!
  edges: [AssetEdge]!
  aggregate: AggregateAsset!
}

input AssetCreateInput {
  id: ID
  name: String!
}

input AssetCreateManyInput {
  create: [AssetCreateInput!]
  connect: [AssetWhereUniqueInput!]
}

input AssetCreateOneInput {
  create: AssetCreateInput
  connect: AssetWhereUniqueInput
}

type AssetEdge {
  node: Asset!
  cursor: String!
}

enum AssetOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
}

type AssetPreviousValues {
  id: ID!
  name: String!
}

input AssetScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  AND: [AssetScalarWhereInput!]
  OR: [AssetScalarWhereInput!]
  NOT: [AssetScalarWhereInput!]
}

type AssetSubscriptionPayload {
  mutation: MutationType!
  node: Asset
  updatedFields: [String!]
  previousValues: AssetPreviousValues
}

input AssetSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: AssetWhereInput
  AND: [AssetSubscriptionWhereInput!]
  OR: [AssetSubscriptionWhereInput!]
  NOT: [AssetSubscriptionWhereInput!]
}

input AssetUpdateDataInput {
  name: String
}

input AssetUpdateInput {
  name: String
}

input AssetUpdateManyDataInput {
  name: String
}

input AssetUpdateManyInput {
  create: [AssetCreateInput!]
  update: [AssetUpdateWithWhereUniqueNestedInput!]
  upsert: [AssetUpsertWithWhereUniqueNestedInput!]
  delete: [AssetWhereUniqueInput!]
  connect: [AssetWhereUniqueInput!]
  set: [AssetWhereUniqueInput!]
  disconnect: [AssetWhereUniqueInput!]
  deleteMany: [AssetScalarWhereInput!]
  updateMany: [AssetUpdateManyWithWhereNestedInput!]
}

input AssetUpdateManyMutationInput {
  name: String
}

input AssetUpdateManyWithWhereNestedInput {
  where: AssetScalarWhereInput!
  data: AssetUpdateManyDataInput!
}

input AssetUpdateOneRequiredInput {
  create: AssetCreateInput
  update: AssetUpdateDataInput
  upsert: AssetUpsertNestedInput
  connect: AssetWhereUniqueInput
}

input AssetUpdateWithWhereUniqueNestedInput {
  where: AssetWhereUniqueInput!
  data: AssetUpdateDataInput!
}

input AssetUpsertNestedInput {
  update: AssetUpdateDataInput!
  create: AssetCreateInput!
}

input AssetUpsertWithWhereUniqueNestedInput {
  where: AssetWhereUniqueInput!
  update: AssetUpdateDataInput!
  create: AssetCreateInput!
}

input AssetWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  AND: [AssetWhereInput!]
  OR: [AssetWhereInput!]
  NOT: [AssetWhereInput!]
}

input AssetWhereUniqueInput {
  id: ID
}

type Attachment {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime
  createdBy: Profile!
  name: String!
  type: AttachmentType!
  link: String
  tags: String
  location: Location
}

type AttachmentConnection {
  pageInfo: PageInfo!
  edges: [AttachmentEdge]!
  aggregate: AggregateAttachment!
}

input AttachmentCreateInput {
  id: ID
  createdBy: ProfileCreateOneInput!
  name: String!
  type: AttachmentType!
  link: String
  tags: String
  location: LocationCreateOneInput
}

input AttachmentCreateManyInput {
  create: [AttachmentCreateInput!]
  connect: [AttachmentWhereUniqueInput!]
}

type AttachmentEdge {
  node: Attachment!
  cursor: String!
}

enum AttachmentOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  name_ASC
  name_DESC
  type_ASC
  type_DESC
  link_ASC
  link_DESC
  tags_ASC
  tags_DESC
}

type AttachmentPreviousValues {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime
  name: String!
  type: AttachmentType!
  link: String
  tags: String
}

input AttachmentScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  type: AttachmentType
  type_not: AttachmentType
  type_in: [AttachmentType!]
  type_not_in: [AttachmentType!]
  link: String
  link_not: String
  link_in: [String!]
  link_not_in: [String!]
  link_lt: String
  link_lte: String
  link_gt: String
  link_gte: String
  link_contains: String
  link_not_contains: String
  link_starts_with: String
  link_not_starts_with: String
  link_ends_with: String
  link_not_ends_with: String
  tags: String
  tags_not: String
  tags_in: [String!]
  tags_not_in: [String!]
  tags_lt: String
  tags_lte: String
  tags_gt: String
  tags_gte: String
  tags_contains: String
  tags_not_contains: String
  tags_starts_with: String
  tags_not_starts_with: String
  tags_ends_with: String
  tags_not_ends_with: String
  AND: [AttachmentScalarWhereInput!]
  OR: [AttachmentScalarWhereInput!]
  NOT: [AttachmentScalarWhereInput!]
}

type AttachmentSubscriptionPayload {
  mutation: MutationType!
  node: Attachment
  updatedFields: [String!]
  previousValues: AttachmentPreviousValues
}

input AttachmentSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: AttachmentWhereInput
  AND: [AttachmentSubscriptionWhereInput!]
  OR: [AttachmentSubscriptionWhereInput!]
  NOT: [AttachmentSubscriptionWhereInput!]
}

enum AttachmentType {
  DOCUMENT
  PICTURE
  LINK
  VIDEO
  AUDIO
}

input AttachmentUpdateDataInput {
  createdBy: ProfileUpdateOneRequiredInput
  name: String
  type: AttachmentType
  link: String
  tags: String
  location: LocationUpdateOneInput
}

input AttachmentUpdateInput {
  createdBy: ProfileUpdateOneRequiredInput
  name: String
  type: AttachmentType
  link: String
  tags: String
  location: LocationUpdateOneInput
}

input AttachmentUpdateManyDataInput {
  name: String
  type: AttachmentType
  link: String
  tags: String
}

input AttachmentUpdateManyInput {
  create: [AttachmentCreateInput!]
  update: [AttachmentUpdateWithWhereUniqueNestedInput!]
  upsert: [AttachmentUpsertWithWhereUniqueNestedInput!]
  delete: [AttachmentWhereUniqueInput!]
  connect: [AttachmentWhereUniqueInput!]
  set: [AttachmentWhereUniqueInput!]
  disconnect: [AttachmentWhereUniqueInput!]
  deleteMany: [AttachmentScalarWhereInput!]
  updateMany: [AttachmentUpdateManyWithWhereNestedInput!]
}

input AttachmentUpdateManyMutationInput {
  name: String
  type: AttachmentType
  link: String
  tags: String
}

input AttachmentUpdateManyWithWhereNestedInput {
  where: AttachmentScalarWhereInput!
  data: AttachmentUpdateManyDataInput!
}

input AttachmentUpdateWithWhereUniqueNestedInput {
  where: AttachmentWhereUniqueInput!
  data: AttachmentUpdateDataInput!
}

input AttachmentUpsertWithWhereUniqueNestedInput {
  where: AttachmentWhereUniqueInput!
  update: AttachmentUpdateDataInput!
  create: AttachmentCreateInput!
}

input AttachmentWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  createdBy: ProfileWhereInput
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  type: AttachmentType
  type_not: AttachmentType
  type_in: [AttachmentType!]
  type_not_in: [AttachmentType!]
  link: String
  link_not: String
  link_in: [String!]
  link_not_in: [String!]
  link_lt: String
  link_lte: String
  link_gt: String
  link_gte: String
  link_contains: String
  link_not_contains: String
  link_starts_with: String
  link_not_starts_with: String
  link_ends_with: String
  link_not_ends_with: String
  tags: String
  tags_not: String
  tags_in: [String!]
  tags_not_in: [String!]
  tags_lt: String
  tags_lte: String
  tags_gt: String
  tags_gte: String
  tags_contains: String
  tags_not_contains: String
  tags_starts_with: String
  tags_not_starts_with: String
  tags_ends_with: String
  tags_not_ends_with: String
  location: LocationWhereInput
  AND: [AttachmentWhereInput!]
  OR: [AttachmentWhereInput!]
  NOT: [AttachmentWhereInput!]
}

input AttachmentWhereUniqueInput {
  id: ID
}

type BatchPayload {
  count: Long!
}

scalar DateTime

type Exchange {
  id: ID!
  name: String!
  assets(where: AssetWhereInput, orderBy: AssetOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Asset!]
}

type ExchangeConnection {
  pageInfo: PageInfo!
  edges: [ExchangeEdge]!
  aggregate: AggregateExchange!
}

input ExchangeCreateInput {
  id: ID
  name: String!
  assets: AssetCreateManyInput
}

input ExchangeCreateOneInput {
  create: ExchangeCreateInput
  connect: ExchangeWhereUniqueInput
}

type ExchangeEdge {
  node: Exchange!
  cursor: String!
}

enum ExchangeOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
}

type ExchangePreviousValues {
  id: ID!
  name: String!
}

type ExchangeSubscriptionPayload {
  mutation: MutationType!
  node: Exchange
  updatedFields: [String!]
  previousValues: ExchangePreviousValues
}

input ExchangeSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ExchangeWhereInput
  AND: [ExchangeSubscriptionWhereInput!]
  OR: [ExchangeSubscriptionWhereInput!]
  NOT: [ExchangeSubscriptionWhereInput!]
}

input ExchangeUpdateDataInput {
  name: String
  assets: AssetUpdateManyInput
}

input ExchangeUpdateInput {
  name: String
  assets: AssetUpdateManyInput
}

input ExchangeUpdateManyMutationInput {
  name: String
}

input ExchangeUpdateOneRequiredInput {
  create: ExchangeCreateInput
  update: ExchangeUpdateDataInput
  upsert: ExchangeUpsertNestedInput
  connect: ExchangeWhereUniqueInput
}

input ExchangeUpsertNestedInput {
  update: ExchangeUpdateDataInput!
  create: ExchangeCreateInput!
}

input ExchangeWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  assets_every: AssetWhereInput
  assets_some: AssetWhereInput
  assets_none: AssetWhereInput
  AND: [ExchangeWhereInput!]
  OR: [ExchangeWhereInput!]
  NOT: [ExchangeWhereInput!]
}

input ExchangeWhereUniqueInput {
  id: ID
}

type Group {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime
  host: Profile!
  name: String!
  title: String!
  description: String!
  logo: String!
  type: GroupType!
  parent: Group
  is_hidden: Boolean!
  is_public: Boolean!
  members(where: MembershipWhereInput, orderBy: MembershipOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Membership!]
  messages(where: MessageWhereInput, orderBy: MessageOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Message!]
  tags: String
  location: Location
}

type GroupConnection {
  pageInfo: PageInfo!
  edges: [GroupEdge]!
  aggregate: AggregateGroup!
}

input GroupCreateInput {
  id: ID
  host: ProfileCreateOneInput!
  name: String!
  title: String!
  description: String!
  logo: String!
  type: GroupType!
  parent: GroupCreateOneInput
  is_hidden: Boolean!
  is_public: Boolean!
  members: MembershipCreateManyWithoutGroupInput
  messages: MessageCreateManyInput
  tags: String
  location: LocationCreateOneInput
}

input GroupCreateOneInput {
  create: GroupCreateInput
  connect: GroupWhereUniqueInput
}

input GroupCreateOneWithoutMembersInput {
  create: GroupCreateWithoutMembersInput
  connect: GroupWhereUniqueInput
}

input GroupCreateWithoutMembersInput {
  id: ID
  host: ProfileCreateOneInput!
  name: String!
  title: String!
  description: String!
  logo: String!
  type: GroupType!
  parent: GroupCreateOneInput
  is_hidden: Boolean!
  is_public: Boolean!
  messages: MessageCreateManyInput
  tags: String
  location: LocationCreateOneInput
}

type GroupEdge {
  node: Group!
  cursor: String!
}

enum GroupOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  name_ASC
  name_DESC
  title_ASC
  title_DESC
  description_ASC
  description_DESC
  logo_ASC
  logo_DESC
  type_ASC
  type_DESC
  is_hidden_ASC
  is_hidden_DESC
  is_public_ASC
  is_public_DESC
  tags_ASC
  tags_DESC
}

type GroupPreviousValues {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime
  name: String!
  title: String!
  description: String!
  logo: String!
  type: GroupType!
  is_hidden: Boolean!
  is_public: Boolean!
  tags: String
}

type GroupSubscriptionPayload {
  mutation: MutationType!
  node: Group
  updatedFields: [String!]
  previousValues: GroupPreviousValues
}

input GroupSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: GroupWhereInput
  AND: [GroupSubscriptionWhereInput!]
  OR: [GroupSubscriptionWhereInput!]
  NOT: [GroupSubscriptionWhereInput!]
}

enum GroupType {
  WORKSPACE
  TEAM
  CONVERSATION
  THREAD
  FRIENDS
}

input GroupUpdateDataInput {
  host: ProfileUpdateOneRequiredInput
  name: String
  title: String
  description: String
  logo: String
  type: GroupType
  parent: GroupUpdateOneInput
  is_hidden: Boolean
  is_public: Boolean
  members: MembershipUpdateManyWithoutGroupInput
  messages: MessageUpdateManyInput
  tags: String
  location: LocationUpdateOneInput
}

input GroupUpdateInput {
  host: ProfileUpdateOneRequiredInput
  name: String
  title: String
  description: String
  logo: String
  type: GroupType
  parent: GroupUpdateOneInput
  is_hidden: Boolean
  is_public: Boolean
  members: MembershipUpdateManyWithoutGroupInput
  messages: MessageUpdateManyInput
  tags: String
  location: LocationUpdateOneInput
}

input GroupUpdateManyMutationInput {
  name: String
  title: String
  description: String
  logo: String
  type: GroupType
  is_hidden: Boolean
  is_public: Boolean
  tags: String
}

input GroupUpdateOneInput {
  create: GroupCreateInput
  update: GroupUpdateDataInput
  upsert: GroupUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: GroupWhereUniqueInput
}

input GroupUpdateOneRequiredWithoutMembersInput {
  create: GroupCreateWithoutMembersInput
  update: GroupUpdateWithoutMembersDataInput
  upsert: GroupUpsertWithoutMembersInput
  connect: GroupWhereUniqueInput
}

input GroupUpdateWithoutMembersDataInput {
  host: ProfileUpdateOneRequiredInput
  name: String
  title: String
  description: String
  logo: String
  type: GroupType
  parent: GroupUpdateOneInput
  is_hidden: Boolean
  is_public: Boolean
  messages: MessageUpdateManyInput
  tags: String
  location: LocationUpdateOneInput
}

input GroupUpsertNestedInput {
  update: GroupUpdateDataInput!
  create: GroupCreateInput!
}

input GroupUpsertWithoutMembersInput {
  update: GroupUpdateWithoutMembersDataInput!
  create: GroupCreateWithoutMembersInput!
}

input GroupWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  host: ProfileWhereInput
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  logo: String
  logo_not: String
  logo_in: [String!]
  logo_not_in: [String!]
  logo_lt: String
  logo_lte: String
  logo_gt: String
  logo_gte: String
  logo_contains: String
  logo_not_contains: String
  logo_starts_with: String
  logo_not_starts_with: String
  logo_ends_with: String
  logo_not_ends_with: String
  type: GroupType
  type_not: GroupType
  type_in: [GroupType!]
  type_not_in: [GroupType!]
  parent: GroupWhereInput
  is_hidden: Boolean
  is_hidden_not: Boolean
  is_public: Boolean
  is_public_not: Boolean
  members_every: MembershipWhereInput
  members_some: MembershipWhereInput
  members_none: MembershipWhereInput
  messages_every: MessageWhereInput
  messages_some: MessageWhereInput
  messages_none: MessageWhereInput
  tags: String
  tags_not: String
  tags_in: [String!]
  tags_not_in: [String!]
  tags_lt: String
  tags_lte: String
  tags_gt: String
  tags_gte: String
  tags_contains: String
  tags_not_contains: String
  tags_starts_with: String
  tags_not_starts_with: String
  tags_ends_with: String
  tags_not_ends_with: String
  location: LocationWhereInput
  AND: [GroupWhereInput!]
  OR: [GroupWhereInput!]
  NOT: [GroupWhereInput!]
}

input GroupWhereUniqueInput {
  id: ID
}

scalar Json

type Location {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  name: String
  latitude: Float!
  longitude: Float!
  radius: Float
}

type LocationConnection {
  pageInfo: PageInfo!
  edges: [LocationEdge]!
  aggregate: AggregateLocation!
}

input LocationCreateInput {
  id: ID
  name: String
  latitude: Float!
  longitude: Float!
  radius: Float
}

input LocationCreateOneInput {
  create: LocationCreateInput
  connect: LocationWhereUniqueInput
}

type LocationEdge {
  node: Location!
  cursor: String!
}

enum LocationOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  name_ASC
  name_DESC
  latitude_ASC
  latitude_DESC
  longitude_ASC
  longitude_DESC
  radius_ASC
  radius_DESC
}

type LocationPreviousValues {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  name: String
  latitude: Float!
  longitude: Float!
  radius: Float
}

type LocationSubscriptionPayload {
  mutation: MutationType!
  node: Location
  updatedFields: [String!]
  previousValues: LocationPreviousValues
}

input LocationSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: LocationWhereInput
  AND: [LocationSubscriptionWhereInput!]
  OR: [LocationSubscriptionWhereInput!]
  NOT: [LocationSubscriptionWhereInput!]
}

input LocationUpdateDataInput {
  name: String
  latitude: Float
  longitude: Float
  radius: Float
}

input LocationUpdateInput {
  name: String
  latitude: Float
  longitude: Float
  radius: Float
}

input LocationUpdateManyMutationInput {
  name: String
  latitude: Float
  longitude: Float
  radius: Float
}

input LocationUpdateOneInput {
  create: LocationCreateInput
  update: LocationUpdateDataInput
  upsert: LocationUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: LocationWhereUniqueInput
}

input LocationUpsertNestedInput {
  update: LocationUpdateDataInput!
  create: LocationCreateInput!
}

input LocationWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  latitude: Float
  latitude_not: Float
  latitude_in: [Float!]
  latitude_not_in: [Float!]
  latitude_lt: Float
  latitude_lte: Float
  latitude_gt: Float
  latitude_gte: Float
  longitude: Float
  longitude_not: Float
  longitude_in: [Float!]
  longitude_not_in: [Float!]
  longitude_lt: Float
  longitude_lte: Float
  longitude_gt: Float
  longitude_gte: Float
  radius: Float
  radius_not: Float
  radius_in: [Float!]
  radius_not_in: [Float!]
  radius_lt: Float
  radius_lte: Float
  radius_gt: Float
  radius_gte: Float
  AND: [LocationWhereInput!]
  OR: [LocationWhereInput!]
  NOT: [LocationWhereInput!]
}

input LocationWhereUniqueInput {
  id: ID
}

scalar Long

type Membership {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime
  member: Profile!
  group: Group!
  show_history: Boolean!
}

type MembershipConnection {
  pageInfo: PageInfo!
  edges: [MembershipEdge]!
  aggregate: AggregateMembership!
}

input MembershipCreateInput {
  id: ID
  member: ProfileCreateOneWithoutMembershipsInput!
  group: GroupCreateOneWithoutMembersInput!
  show_history: Boolean!
}

input MembershipCreateManyWithoutGroupInput {
  create: [MembershipCreateWithoutGroupInput!]
  connect: [MembershipWhereUniqueInput!]
}

input MembershipCreateManyWithoutMemberInput {
  create: [MembershipCreateWithoutMemberInput!]
  connect: [MembershipWhereUniqueInput!]
}

input MembershipCreateWithoutGroupInput {
  id: ID
  member: ProfileCreateOneWithoutMembershipsInput!
  show_history: Boolean!
}

input MembershipCreateWithoutMemberInput {
  id: ID
  group: GroupCreateOneWithoutMembersInput!
  show_history: Boolean!
}

type MembershipEdge {
  node: Membership!
  cursor: String!
}

enum MembershipOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  show_history_ASC
  show_history_DESC
}

type MembershipPreviousValues {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime
  show_history: Boolean!
}

input MembershipScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  show_history: Boolean
  show_history_not: Boolean
  AND: [MembershipScalarWhereInput!]
  OR: [MembershipScalarWhereInput!]
  NOT: [MembershipScalarWhereInput!]
}

type MembershipSubscriptionPayload {
  mutation: MutationType!
  node: Membership
  updatedFields: [String!]
  previousValues: MembershipPreviousValues
}

input MembershipSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: MembershipWhereInput
  AND: [MembershipSubscriptionWhereInput!]
  OR: [MembershipSubscriptionWhereInput!]
  NOT: [MembershipSubscriptionWhereInput!]
}

input MembershipUpdateInput {
  member: ProfileUpdateOneRequiredWithoutMembershipsInput
  group: GroupUpdateOneRequiredWithoutMembersInput
  show_history: Boolean
}

input MembershipUpdateManyDataInput {
  show_history: Boolean
}

input MembershipUpdateManyMutationInput {
  show_history: Boolean
}

input MembershipUpdateManyWithoutGroupInput {
  create: [MembershipCreateWithoutGroupInput!]
  delete: [MembershipWhereUniqueInput!]
  connect: [MembershipWhereUniqueInput!]
  set: [MembershipWhereUniqueInput!]
  disconnect: [MembershipWhereUniqueInput!]
  update: [MembershipUpdateWithWhereUniqueWithoutGroupInput!]
  upsert: [MembershipUpsertWithWhereUniqueWithoutGroupInput!]
  deleteMany: [MembershipScalarWhereInput!]
  updateMany: [MembershipUpdateManyWithWhereNestedInput!]
}

input MembershipUpdateManyWithoutMemberInput {
  create: [MembershipCreateWithoutMemberInput!]
  delete: [MembershipWhereUniqueInput!]
  connect: [MembershipWhereUniqueInput!]
  set: [MembershipWhereUniqueInput!]
  disconnect: [MembershipWhereUniqueInput!]
  update: [MembershipUpdateWithWhereUniqueWithoutMemberInput!]
  upsert: [MembershipUpsertWithWhereUniqueWithoutMemberInput!]
  deleteMany: [MembershipScalarWhereInput!]
  updateMany: [MembershipUpdateManyWithWhereNestedInput!]
}

input MembershipUpdateManyWithWhereNestedInput {
  where: MembershipScalarWhereInput!
  data: MembershipUpdateManyDataInput!
}

input MembershipUpdateWithoutGroupDataInput {
  member: ProfileUpdateOneRequiredWithoutMembershipsInput
  show_history: Boolean
}

input MembershipUpdateWithoutMemberDataInput {
  group: GroupUpdateOneRequiredWithoutMembersInput
  show_history: Boolean
}

input MembershipUpdateWithWhereUniqueWithoutGroupInput {
  where: MembershipWhereUniqueInput!
  data: MembershipUpdateWithoutGroupDataInput!
}

input MembershipUpdateWithWhereUniqueWithoutMemberInput {
  where: MembershipWhereUniqueInput!
  data: MembershipUpdateWithoutMemberDataInput!
}

input MembershipUpsertWithWhereUniqueWithoutGroupInput {
  where: MembershipWhereUniqueInput!
  update: MembershipUpdateWithoutGroupDataInput!
  create: MembershipCreateWithoutGroupInput!
}

input MembershipUpsertWithWhereUniqueWithoutMemberInput {
  where: MembershipWhereUniqueInput!
  update: MembershipUpdateWithoutMemberDataInput!
  create: MembershipCreateWithoutMemberInput!
}

input MembershipWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  member: ProfileWhereInput
  group: GroupWhereInput
  show_history: Boolean
  show_history_not: Boolean
  AND: [MembershipWhereInput!]
  OR: [MembershipWhereInput!]
  NOT: [MembershipWhereInput!]
}

input MembershipWhereUniqueInput {
  id: ID
}

type Message {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime
  sender: Profile!
  type: MessageType!
  parent: Message
  subject: String
  content: Json
  attachments(where: AttachmentWhereInput, orderBy: AttachmentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Attachment!]
  reactions(where: ReactionWhereInput, orderBy: ReactionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Reaction!]
  tags: String
  location: Location
}

type MessageConnection {
  pageInfo: PageInfo!
  edges: [MessageEdge]!
  aggregate: AggregateMessage!
}

input MessageCreateInput {
  id: ID
  sender: ProfileCreateOneInput!
  type: MessageType!
  parent: MessageCreateOneInput
  subject: String
  content: Json
  attachments: AttachmentCreateManyInput
  reactions: ReactionCreateManyInput
  tags: String
  location: LocationCreateOneInput
}

input MessageCreateManyInput {
  create: [MessageCreateInput!]
  connect: [MessageWhereUniqueInput!]
}

input MessageCreateOneInput {
  create: MessageCreateInput
  connect: MessageWhereUniqueInput
}

type MessageEdge {
  node: Message!
  cursor: String!
}

enum MessageOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  type_ASC
  type_DESC
  subject_ASC
  subject_DESC
  content_ASC
  content_DESC
  tags_ASC
  tags_DESC
}

type MessagePreviousValues {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime
  type: MessageType!
  subject: String
  content: Json
  tags: String
}

input MessageScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  type: MessageType
  type_not: MessageType
  type_in: [MessageType!]
  type_not_in: [MessageType!]
  subject: String
  subject_not: String
  subject_in: [String!]
  subject_not_in: [String!]
  subject_lt: String
  subject_lte: String
  subject_gt: String
  subject_gte: String
  subject_contains: String
  subject_not_contains: String
  subject_starts_with: String
  subject_not_starts_with: String
  subject_ends_with: String
  subject_not_ends_with: String
  tags: String
  tags_not: String
  tags_in: [String!]
  tags_not_in: [String!]
  tags_lt: String
  tags_lte: String
  tags_gt: String
  tags_gte: String
  tags_contains: String
  tags_not_contains: String
  tags_starts_with: String
  tags_not_starts_with: String
  tags_ends_with: String
  tags_not_ends_with: String
  AND: [MessageScalarWhereInput!]
  OR: [MessageScalarWhereInput!]
  NOT: [MessageScalarWhereInput!]
}

type MessageSubscriptionPayload {
  mutation: MutationType!
  node: Message
  updatedFields: [String!]
  previousValues: MessagePreviousValues
}

input MessageSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: MessageWhereInput
  AND: [MessageSubscriptionWhereInput!]
  OR: [MessageSubscriptionWhereInput!]
  NOT: [MessageSubscriptionWhereInput!]
}

enum MessageType {
  NOTIFICATION
  DIRECT_MESSAGE
  COMMENT
  POST
  CHART_FLAG
  TRAIL
}

input MessageUpdateDataInput {
  sender: ProfileUpdateOneRequiredInput
  type: MessageType
  parent: MessageUpdateOneInput
  subject: String
  content: Json
  attachments: AttachmentUpdateManyInput
  reactions: ReactionUpdateManyInput
  tags: String
  location: LocationUpdateOneInput
}

input MessageUpdateInput {
  sender: ProfileUpdateOneRequiredInput
  type: MessageType
  parent: MessageUpdateOneInput
  subject: String
  content: Json
  attachments: AttachmentUpdateManyInput
  reactions: ReactionUpdateManyInput
  tags: String
  location: LocationUpdateOneInput
}

input MessageUpdateManyDataInput {
  type: MessageType
  subject: String
  content: Json
  tags: String
}

input MessageUpdateManyInput {
  create: [MessageCreateInput!]
  update: [MessageUpdateWithWhereUniqueNestedInput!]
  upsert: [MessageUpsertWithWhereUniqueNestedInput!]
  delete: [MessageWhereUniqueInput!]
  connect: [MessageWhereUniqueInput!]
  set: [MessageWhereUniqueInput!]
  disconnect: [MessageWhereUniqueInput!]
  deleteMany: [MessageScalarWhereInput!]
  updateMany: [MessageUpdateManyWithWhereNestedInput!]
}

input MessageUpdateManyMutationInput {
  type: MessageType
  subject: String
  content: Json
  tags: String
}

input MessageUpdateManyWithWhereNestedInput {
  where: MessageScalarWhereInput!
  data: MessageUpdateManyDataInput!
}

input MessageUpdateOneInput {
  create: MessageCreateInput
  update: MessageUpdateDataInput
  upsert: MessageUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: MessageWhereUniqueInput
}

input MessageUpdateWithWhereUniqueNestedInput {
  where: MessageWhereUniqueInput!
  data: MessageUpdateDataInput!
}

input MessageUpsertNestedInput {
  update: MessageUpdateDataInput!
  create: MessageCreateInput!
}

input MessageUpsertWithWhereUniqueNestedInput {
  where: MessageWhereUniqueInput!
  update: MessageUpdateDataInput!
  create: MessageCreateInput!
}

input MessageWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  sender: ProfileWhereInput
  type: MessageType
  type_not: MessageType
  type_in: [MessageType!]
  type_not_in: [MessageType!]
  parent: MessageWhereInput
  subject: String
  subject_not: String
  subject_in: [String!]
  subject_not_in: [String!]
  subject_lt: String
  subject_lte: String
  subject_gt: String
  subject_gte: String
  subject_contains: String
  subject_not_contains: String
  subject_starts_with: String
  subject_not_starts_with: String
  subject_ends_with: String
  subject_not_ends_with: String
  attachments_every: AttachmentWhereInput
  attachments_some: AttachmentWhereInput
  attachments_none: AttachmentWhereInput
  reactions_every: ReactionWhereInput
  reactions_some: ReactionWhereInput
  reactions_none: ReactionWhereInput
  tags: String
  tags_not: String
  tags_in: [String!]
  tags_not_in: [String!]
  tags_lt: String
  tags_lte: String
  tags_gt: String
  tags_gte: String
  tags_contains: String
  tags_not_contains: String
  tags_starts_with: String
  tags_not_starts_with: String
  tags_ends_with: String
  tags_not_ends_with: String
  location: LocationWhereInput
  AND: [MessageWhereInput!]
  OR: [MessageWhereInput!]
  NOT: [MessageWhereInput!]
}

input MessageWhereUniqueInput {
  id: ID
}

type Mutation {
  createAsset(data: AssetCreateInput!): Asset!
  updateAsset(data: AssetUpdateInput!, where: AssetWhereUniqueInput!): Asset
  updateManyAssets(data: AssetUpdateManyMutationInput!, where: AssetWhereInput): BatchPayload!
  upsertAsset(where: AssetWhereUniqueInput!, create: AssetCreateInput!, update: AssetUpdateInput!): Asset!
  deleteAsset(where: AssetWhereUniqueInput!): Asset
  deleteManyAssets(where: AssetWhereInput): BatchPayload!
  createAttachment(data: AttachmentCreateInput!): Attachment!
  updateAttachment(data: AttachmentUpdateInput!, where: AttachmentWhereUniqueInput!): Attachment
  updateManyAttachments(data: AttachmentUpdateManyMutationInput!, where: AttachmentWhereInput): BatchPayload!
  upsertAttachment(where: AttachmentWhereUniqueInput!, create: AttachmentCreateInput!, update: AttachmentUpdateInput!): Attachment!
  deleteAttachment(where: AttachmentWhereUniqueInput!): Attachment
  deleteManyAttachments(where: AttachmentWhereInput): BatchPayload!
  createExchange(data: ExchangeCreateInput!): Exchange!
  updateExchange(data: ExchangeUpdateInput!, where: ExchangeWhereUniqueInput!): Exchange
  updateManyExchanges(data: ExchangeUpdateManyMutationInput!, where: ExchangeWhereInput): BatchPayload!
  upsertExchange(where: ExchangeWhereUniqueInput!, create: ExchangeCreateInput!, update: ExchangeUpdateInput!): Exchange!
  deleteExchange(where: ExchangeWhereUniqueInput!): Exchange
  deleteManyExchanges(where: ExchangeWhereInput): BatchPayload!
  createGroup(data: GroupCreateInput!): Group!
  updateGroup(data: GroupUpdateInput!, where: GroupWhereUniqueInput!): Group
  updateManyGroups(data: GroupUpdateManyMutationInput!, where: GroupWhereInput): BatchPayload!
  upsertGroup(where: GroupWhereUniqueInput!, create: GroupCreateInput!, update: GroupUpdateInput!): Group!
  deleteGroup(where: GroupWhereUniqueInput!): Group
  deleteManyGroups(where: GroupWhereInput): BatchPayload!
  createLocation(data: LocationCreateInput!): Location!
  updateLocation(data: LocationUpdateInput!, where: LocationWhereUniqueInput!): Location
  updateManyLocations(data: LocationUpdateManyMutationInput!, where: LocationWhereInput): BatchPayload!
  upsertLocation(where: LocationWhereUniqueInput!, create: LocationCreateInput!, update: LocationUpdateInput!): Location!
  deleteLocation(where: LocationWhereUniqueInput!): Location
  deleteManyLocations(where: LocationWhereInput): BatchPayload!
  createMembership(data: MembershipCreateInput!): Membership!
  updateMembership(data: MembershipUpdateInput!, where: MembershipWhereUniqueInput!): Membership
  updateManyMemberships(data: MembershipUpdateManyMutationInput!, where: MembershipWhereInput): BatchPayload!
  upsertMembership(where: MembershipWhereUniqueInput!, create: MembershipCreateInput!, update: MembershipUpdateInput!): Membership!
  deleteMembership(where: MembershipWhereUniqueInput!): Membership
  deleteManyMemberships(where: MembershipWhereInput): BatchPayload!
  createMessage(data: MessageCreateInput!): Message!
  updateMessage(data: MessageUpdateInput!, where: MessageWhereUniqueInput!): Message
  updateManyMessages(data: MessageUpdateManyMutationInput!, where: MessageWhereInput): BatchPayload!
  upsertMessage(where: MessageWhereUniqueInput!, create: MessageCreateInput!, update: MessageUpdateInput!): Message!
  deleteMessage(where: MessageWhereUniqueInput!): Message
  deleteManyMessages(where: MessageWhereInput): BatchPayload!
  createPortfolio(data: PortfolioCreateInput!): Portfolio!
  updatePortfolio(data: PortfolioUpdateInput!, where: PortfolioWhereUniqueInput!): Portfolio
  updateManyPortfolios(data: PortfolioUpdateManyMutationInput!, where: PortfolioWhereInput): BatchPayload!
  upsertPortfolio(where: PortfolioWhereUniqueInput!, create: PortfolioCreateInput!, update: PortfolioUpdateInput!): Portfolio!
  deletePortfolio(where: PortfolioWhereUniqueInput!): Portfolio
  deleteManyPortfolios(where: PortfolioWhereInput): BatchPayload!
  createProfile(data: ProfileCreateInput!): Profile!
  updateProfile(data: ProfileUpdateInput!, where: ProfileWhereUniqueInput!): Profile
  updateManyProfiles(data: ProfileUpdateManyMutationInput!, where: ProfileWhereInput): BatchPayload!
  upsertProfile(where: ProfileWhereUniqueInput!, create: ProfileCreateInput!, update: ProfileUpdateInput!): Profile!
  deleteProfile(where: ProfileWhereUniqueInput!): Profile
  deleteManyProfiles(where: ProfileWhereInput): BatchPayload!
  createReaction(data: ReactionCreateInput!): Reaction!
  updateReaction(data: ReactionUpdateInput!, where: ReactionWhereUniqueInput!): Reaction
  updateManyReactions(data: ReactionUpdateManyMutationInput!, where: ReactionWhereInput): BatchPayload!
  upsertReaction(where: ReactionWhereUniqueInput!, create: ReactionCreateInput!, update: ReactionUpdateInput!): Reaction!
  deleteReaction(where: ReactionWhereUniqueInput!): Reaction
  deleteManyReactions(where: ReactionWhereInput): BatchPayload!
  createSession(data: SessionCreateInput!): Session!
  updateSession(data: SessionUpdateInput!, where: SessionWhereUniqueInput!): Session
  updateManySessions(data: SessionUpdateManyMutationInput!, where: SessionWhereInput): BatchPayload!
  upsertSession(where: SessionWhereUniqueInput!, create: SessionCreateInput!, update: SessionUpdateInput!): Session!
  deleteSession(where: SessionWhereUniqueInput!): Session
  deleteManySessions(where: SessionWhereInput): BatchPayload!
  createTransaction(data: TransactionCreateInput!): Transaction!
  updateTransaction(data: TransactionUpdateInput!, where: TransactionWhereUniqueInput!): Transaction
  updateManyTransactions(data: TransactionUpdateManyMutationInput!, where: TransactionWhereInput): BatchPayload!
  upsertTransaction(where: TransactionWhereUniqueInput!, create: TransactionCreateInput!, update: TransactionUpdateInput!): Transaction!
  deleteTransaction(where: TransactionWhereUniqueInput!): Transaction
  deleteManyTransactions(where: TransactionWhereInput): BatchPayload!
  createUser(data: UserCreateInput!): User!
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  updateManyUsers(data: UserUpdateManyMutationInput!, where: UserWhereInput): BatchPayload!
  upsertUser(where: UserWhereUniqueInput!, create: UserCreateInput!, update: UserUpdateInput!): User!
  deleteUser(where: UserWhereUniqueInput!): User
  deleteManyUsers(where: UserWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Portfolio {
  id: ID!
  owner: Profile!
  name: String!
  transactions(where: TransactionWhereInput, orderBy: TransactionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Transaction!]
}

type PortfolioConnection {
  pageInfo: PageInfo!
  edges: [PortfolioEdge]!
  aggregate: AggregatePortfolio!
}

input PortfolioCreateInput {
  id: ID
  owner: ProfileCreateOneInput!
  name: String!
  transactions: TransactionCreateManyInput
}

type PortfolioEdge {
  node: Portfolio!
  cursor: String!
}

enum PortfolioOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
}

type PortfolioPreviousValues {
  id: ID!
  name: String!
}

type PortfolioSubscriptionPayload {
  mutation: MutationType!
  node: Portfolio
  updatedFields: [String!]
  previousValues: PortfolioPreviousValues
}

input PortfolioSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: PortfolioWhereInput
  AND: [PortfolioSubscriptionWhereInput!]
  OR: [PortfolioSubscriptionWhereInput!]
  NOT: [PortfolioSubscriptionWhereInput!]
}

input PortfolioUpdateInput {
  owner: ProfileUpdateOneRequiredInput
  name: String
  transactions: TransactionUpdateManyInput
}

input PortfolioUpdateManyMutationInput {
  name: String
}

input PortfolioWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  owner: ProfileWhereInput
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  transactions_every: TransactionWhereInput
  transactions_some: TransactionWhereInput
  transactions_none: TransactionWhereInput
  AND: [PortfolioWhereInput!]
  OR: [PortfolioWhereInput!]
  NOT: [PortfolioWhereInput!]
}

input PortfolioWhereUniqueInput {
  id: ID
}

type Profile {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime
  name: String!
  timezone: String
  status: String
  picture: String!
  memberships(where: MembershipWhereInput, orderBy: MembershipOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Membership!]
  location: Location
}

type ProfileConnection {
  pageInfo: PageInfo!
  edges: [ProfileEdge]!
  aggregate: AggregateProfile!
}

input ProfileCreateInput {
  id: ID
  name: String!
  timezone: String
  status: String
  picture: String!
  memberships: MembershipCreateManyWithoutMemberInput
  location: LocationCreateOneInput
}

input ProfileCreateManyInput {
  create: [ProfileCreateInput!]
  connect: [ProfileWhereUniqueInput!]
}

input ProfileCreateOneInput {
  create: ProfileCreateInput
  connect: ProfileWhereUniqueInput
}

input ProfileCreateOneWithoutMembershipsInput {
  create: ProfileCreateWithoutMembershipsInput
  connect: ProfileWhereUniqueInput
}

input ProfileCreateWithoutMembershipsInput {
  id: ID
  name: String!
  timezone: String
  status: String
  picture: String!
  location: LocationCreateOneInput
}

type ProfileEdge {
  node: Profile!
  cursor: String!
}

enum ProfileOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  name_ASC
  name_DESC
  timezone_ASC
  timezone_DESC
  status_ASC
  status_DESC
  picture_ASC
  picture_DESC
}

type ProfilePreviousValues {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime
  name: String!
  timezone: String
  status: String
  picture: String!
}

input ProfileScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  timezone: String
  timezone_not: String
  timezone_in: [String!]
  timezone_not_in: [String!]
  timezone_lt: String
  timezone_lte: String
  timezone_gt: String
  timezone_gte: String
  timezone_contains: String
  timezone_not_contains: String
  timezone_starts_with: String
  timezone_not_starts_with: String
  timezone_ends_with: String
  timezone_not_ends_with: String
  status: String
  status_not: String
  status_in: [String!]
  status_not_in: [String!]
  status_lt: String
  status_lte: String
  status_gt: String
  status_gte: String
  status_contains: String
  status_not_contains: String
  status_starts_with: String
  status_not_starts_with: String
  status_ends_with: String
  status_not_ends_with: String
  picture: String
  picture_not: String
  picture_in: [String!]
  picture_not_in: [String!]
  picture_lt: String
  picture_lte: String
  picture_gt: String
  picture_gte: String
  picture_contains: String
  picture_not_contains: String
  picture_starts_with: String
  picture_not_starts_with: String
  picture_ends_with: String
  picture_not_ends_with: String
  AND: [ProfileScalarWhereInput!]
  OR: [ProfileScalarWhereInput!]
  NOT: [ProfileScalarWhereInput!]
}

type ProfileSubscriptionPayload {
  mutation: MutationType!
  node: Profile
  updatedFields: [String!]
  previousValues: ProfilePreviousValues
}

input ProfileSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ProfileWhereInput
  AND: [ProfileSubscriptionWhereInput!]
  OR: [ProfileSubscriptionWhereInput!]
  NOT: [ProfileSubscriptionWhereInput!]
}

input ProfileUpdateDataInput {
  name: String
  timezone: String
  status: String
  picture: String
  memberships: MembershipUpdateManyWithoutMemberInput
  location: LocationUpdateOneInput
}

input ProfileUpdateInput {
  name: String
  timezone: String
  status: String
  picture: String
  memberships: MembershipUpdateManyWithoutMemberInput
  location: LocationUpdateOneInput
}

input ProfileUpdateManyDataInput {
  name: String
  timezone: String
  status: String
  picture: String
}

input ProfileUpdateManyInput {
  create: [ProfileCreateInput!]
  update: [ProfileUpdateWithWhereUniqueNestedInput!]
  upsert: [ProfileUpsertWithWhereUniqueNestedInput!]
  delete: [ProfileWhereUniqueInput!]
  connect: [ProfileWhereUniqueInput!]
  set: [ProfileWhereUniqueInput!]
  disconnect: [ProfileWhereUniqueInput!]
  deleteMany: [ProfileScalarWhereInput!]
  updateMany: [ProfileUpdateManyWithWhereNestedInput!]
}

input ProfileUpdateManyMutationInput {
  name: String
  timezone: String
  status: String
  picture: String
}

input ProfileUpdateManyWithWhereNestedInput {
  where: ProfileScalarWhereInput!
  data: ProfileUpdateManyDataInput!
}

input ProfileUpdateOneInput {
  create: ProfileCreateInput
  update: ProfileUpdateDataInput
  upsert: ProfileUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: ProfileWhereUniqueInput
}

input ProfileUpdateOneRequiredInput {
  create: ProfileCreateInput
  update: ProfileUpdateDataInput
  upsert: ProfileUpsertNestedInput
  connect: ProfileWhereUniqueInput
}

input ProfileUpdateOneRequiredWithoutMembershipsInput {
  create: ProfileCreateWithoutMembershipsInput
  update: ProfileUpdateWithoutMembershipsDataInput
  upsert: ProfileUpsertWithoutMembershipsInput
  connect: ProfileWhereUniqueInput
}

input ProfileUpdateWithoutMembershipsDataInput {
  name: String
  timezone: String
  status: String
  picture: String
  location: LocationUpdateOneInput
}

input ProfileUpdateWithWhereUniqueNestedInput {
  where: ProfileWhereUniqueInput!
  data: ProfileUpdateDataInput!
}

input ProfileUpsertNestedInput {
  update: ProfileUpdateDataInput!
  create: ProfileCreateInput!
}

input ProfileUpsertWithoutMembershipsInput {
  update: ProfileUpdateWithoutMembershipsDataInput!
  create: ProfileCreateWithoutMembershipsInput!
}

input ProfileUpsertWithWhereUniqueNestedInput {
  where: ProfileWhereUniqueInput!
  update: ProfileUpdateDataInput!
  create: ProfileCreateInput!
}

input ProfileWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  timezone: String
  timezone_not: String
  timezone_in: [String!]
  timezone_not_in: [String!]
  timezone_lt: String
  timezone_lte: String
  timezone_gt: String
  timezone_gte: String
  timezone_contains: String
  timezone_not_contains: String
  timezone_starts_with: String
  timezone_not_starts_with: String
  timezone_ends_with: String
  timezone_not_ends_with: String
  status: String
  status_not: String
  status_in: [String!]
  status_not_in: [String!]
  status_lt: String
  status_lte: String
  status_gt: String
  status_gte: String
  status_contains: String
  status_not_contains: String
  status_starts_with: String
  status_not_starts_with: String
  status_ends_with: String
  status_not_ends_with: String
  picture: String
  picture_not: String
  picture_in: [String!]
  picture_not_in: [String!]
  picture_lt: String
  picture_lte: String
  picture_gt: String
  picture_gte: String
  picture_contains: String
  picture_not_contains: String
  picture_starts_with: String
  picture_not_starts_with: String
  picture_ends_with: String
  picture_not_ends_with: String
  memberships_every: MembershipWhereInput
  memberships_some: MembershipWhereInput
  memberships_none: MembershipWhereInput
  location: LocationWhereInput
  AND: [ProfileWhereInput!]
  OR: [ProfileWhereInput!]
  NOT: [ProfileWhereInput!]
}

input ProfileWhereUniqueInput {
  id: ID
}

type Query {
  asset(where: AssetWhereUniqueInput!): Asset
  assets(where: AssetWhereInput, orderBy: AssetOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Asset]!
  assetsConnection(where: AssetWhereInput, orderBy: AssetOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): AssetConnection!
  attachment(where: AttachmentWhereUniqueInput!): Attachment
  attachments(where: AttachmentWhereInput, orderBy: AttachmentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Attachment]!
  attachmentsConnection(where: AttachmentWhereInput, orderBy: AttachmentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): AttachmentConnection!
  exchange(where: ExchangeWhereUniqueInput!): Exchange
  exchanges(where: ExchangeWhereInput, orderBy: ExchangeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Exchange]!
  exchangesConnection(where: ExchangeWhereInput, orderBy: ExchangeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ExchangeConnection!
  group(where: GroupWhereUniqueInput!): Group
  groups(where: GroupWhereInput, orderBy: GroupOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Group]!
  groupsConnection(where: GroupWhereInput, orderBy: GroupOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): GroupConnection!
  location(where: LocationWhereUniqueInput!): Location
  locations(where: LocationWhereInput, orderBy: LocationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Location]!
  locationsConnection(where: LocationWhereInput, orderBy: LocationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): LocationConnection!
  membership(where: MembershipWhereUniqueInput!): Membership
  memberships(where: MembershipWhereInput, orderBy: MembershipOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Membership]!
  membershipsConnection(where: MembershipWhereInput, orderBy: MembershipOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): MembershipConnection!
  message(where: MessageWhereUniqueInput!): Message
  messages(where: MessageWhereInput, orderBy: MessageOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Message]!
  messagesConnection(where: MessageWhereInput, orderBy: MessageOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): MessageConnection!
  portfolio(where: PortfolioWhereUniqueInput!): Portfolio
  portfolios(where: PortfolioWhereInput, orderBy: PortfolioOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Portfolio]!
  portfoliosConnection(where: PortfolioWhereInput, orderBy: PortfolioOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PortfolioConnection!
  profile(where: ProfileWhereUniqueInput!): Profile
  profiles(where: ProfileWhereInput, orderBy: ProfileOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Profile]!
  profilesConnection(where: ProfileWhereInput, orderBy: ProfileOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ProfileConnection!
  reaction(where: ReactionWhereUniqueInput!): Reaction
  reactions(where: ReactionWhereInput, orderBy: ReactionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Reaction]!
  reactionsConnection(where: ReactionWhereInput, orderBy: ReactionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ReactionConnection!
  session(where: SessionWhereUniqueInput!): Session
  sessions(where: SessionWhereInput, orderBy: SessionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Session]!
  sessionsConnection(where: SessionWhereInput, orderBy: SessionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): SessionConnection!
  transaction(where: TransactionWhereUniqueInput!): Transaction
  transactions(where: TransactionWhereInput, orderBy: TransactionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Transaction]!
  transactionsConnection(where: TransactionWhereInput, orderBy: TransactionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): TransactionConnection!
  user(where: UserWhereUniqueInput!): User
  users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User]!
  usersConnection(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserConnection!
  node(id: ID!): Node
}

type Reaction {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime
  creator: Profile!
  emoji: String!
}

type ReactionConnection {
  pageInfo: PageInfo!
  edges: [ReactionEdge]!
  aggregate: AggregateReaction!
}

input ReactionCreateInput {
  id: ID
  creator: ProfileCreateOneInput!
  emoji: String!
}

input ReactionCreateManyInput {
  create: [ReactionCreateInput!]
  connect: [ReactionWhereUniqueInput!]
}

type ReactionEdge {
  node: Reaction!
  cursor: String!
}

enum ReactionOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  emoji_ASC
  emoji_DESC
}

type ReactionPreviousValues {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime
  emoji: String!
}

input ReactionScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  emoji: String
  emoji_not: String
  emoji_in: [String!]
  emoji_not_in: [String!]
  emoji_lt: String
  emoji_lte: String
  emoji_gt: String
  emoji_gte: String
  emoji_contains: String
  emoji_not_contains: String
  emoji_starts_with: String
  emoji_not_starts_with: String
  emoji_ends_with: String
  emoji_not_ends_with: String
  AND: [ReactionScalarWhereInput!]
  OR: [ReactionScalarWhereInput!]
  NOT: [ReactionScalarWhereInput!]
}

type ReactionSubscriptionPayload {
  mutation: MutationType!
  node: Reaction
  updatedFields: [String!]
  previousValues: ReactionPreviousValues
}

input ReactionSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ReactionWhereInput
  AND: [ReactionSubscriptionWhereInput!]
  OR: [ReactionSubscriptionWhereInput!]
  NOT: [ReactionSubscriptionWhereInput!]
}

input ReactionUpdateDataInput {
  creator: ProfileUpdateOneRequiredInput
  emoji: String
}

input ReactionUpdateInput {
  creator: ProfileUpdateOneRequiredInput
  emoji: String
}

input ReactionUpdateManyDataInput {
  emoji: String
}

input ReactionUpdateManyInput {
  create: [ReactionCreateInput!]
  update: [ReactionUpdateWithWhereUniqueNestedInput!]
  upsert: [ReactionUpsertWithWhereUniqueNestedInput!]
  delete: [ReactionWhereUniqueInput!]
  connect: [ReactionWhereUniqueInput!]
  set: [ReactionWhereUniqueInput!]
  disconnect: [ReactionWhereUniqueInput!]
  deleteMany: [ReactionScalarWhereInput!]
  updateMany: [ReactionUpdateManyWithWhereNestedInput!]
}

input ReactionUpdateManyMutationInput {
  emoji: String
}

input ReactionUpdateManyWithWhereNestedInput {
  where: ReactionScalarWhereInput!
  data: ReactionUpdateManyDataInput!
}

input ReactionUpdateWithWhereUniqueNestedInput {
  where: ReactionWhereUniqueInput!
  data: ReactionUpdateDataInput!
}

input ReactionUpsertWithWhereUniqueNestedInput {
  where: ReactionWhereUniqueInput!
  update: ReactionUpdateDataInput!
  create: ReactionCreateInput!
}

input ReactionWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  creator: ProfileWhereInput
  emoji: String
  emoji_not: String
  emoji_in: [String!]
  emoji_not_in: [String!]
  emoji_lt: String
  emoji_lte: String
  emoji_gt: String
  emoji_gte: String
  emoji_contains: String
  emoji_not_contains: String
  emoji_starts_with: String
  emoji_not_starts_with: String
  emoji_ends_with: String
  emoji_not_ends_with: String
  AND: [ReactionWhereInput!]
  OR: [ReactionWhereInput!]
  NOT: [ReactionWhereInput!]
}

input ReactionWhereUniqueInput {
  id: ID
}

type Session {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime
  token: String!
  validTo: DateTime!
  timedOut: DateTime
  user: User!
  profile: Profile
}

type SessionConnection {
  pageInfo: PageInfo!
  edges: [SessionEdge]!
  aggregate: AggregateSession!
}

input SessionCreateInput {
  id: ID
  token: String!
  validTo: DateTime!
  timedOut: DateTime
  user: UserCreateOneWithoutSessionsInput!
  profile: ProfileCreateOneInput
}

input SessionCreateManyWithoutUserInput {
  create: [SessionCreateWithoutUserInput!]
  connect: [SessionWhereUniqueInput!]
}

input SessionCreateWithoutUserInput {
  id: ID
  token: String!
  validTo: DateTime!
  timedOut: DateTime
  profile: ProfileCreateOneInput
}

type SessionEdge {
  node: Session!
  cursor: String!
}

enum SessionOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  token_ASC
  token_DESC
  validTo_ASC
  validTo_DESC
  timedOut_ASC
  timedOut_DESC
}

type SessionPreviousValues {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime
  token: String!
  validTo: DateTime!
  timedOut: DateTime
}

input SessionScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  token: String
  token_not: String
  token_in: [String!]
  token_not_in: [String!]
  token_lt: String
  token_lte: String
  token_gt: String
  token_gte: String
  token_contains: String
  token_not_contains: String
  token_starts_with: String
  token_not_starts_with: String
  token_ends_with: String
  token_not_ends_with: String
  validTo: DateTime
  validTo_not: DateTime
  validTo_in: [DateTime!]
  validTo_not_in: [DateTime!]
  validTo_lt: DateTime
  validTo_lte: DateTime
  validTo_gt: DateTime
  validTo_gte: DateTime
  timedOut: DateTime
  timedOut_not: DateTime
  timedOut_in: [DateTime!]
  timedOut_not_in: [DateTime!]
  timedOut_lt: DateTime
  timedOut_lte: DateTime
  timedOut_gt: DateTime
  timedOut_gte: DateTime
  AND: [SessionScalarWhereInput!]
  OR: [SessionScalarWhereInput!]
  NOT: [SessionScalarWhereInput!]
}

type SessionSubscriptionPayload {
  mutation: MutationType!
  node: Session
  updatedFields: [String!]
  previousValues: SessionPreviousValues
}

input SessionSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: SessionWhereInput
  AND: [SessionSubscriptionWhereInput!]
  OR: [SessionSubscriptionWhereInput!]
  NOT: [SessionSubscriptionWhereInput!]
}

input SessionUpdateInput {
  token: String
  validTo: DateTime
  timedOut: DateTime
  user: UserUpdateOneRequiredWithoutSessionsInput
  profile: ProfileUpdateOneInput
}

input SessionUpdateManyDataInput {
  token: String
  validTo: DateTime
  timedOut: DateTime
}

input SessionUpdateManyMutationInput {
  token: String
  validTo: DateTime
  timedOut: DateTime
}

input SessionUpdateManyWithoutUserInput {
  create: [SessionCreateWithoutUserInput!]
  delete: [SessionWhereUniqueInput!]
  connect: [SessionWhereUniqueInput!]
  set: [SessionWhereUniqueInput!]
  disconnect: [SessionWhereUniqueInput!]
  update: [SessionUpdateWithWhereUniqueWithoutUserInput!]
  upsert: [SessionUpsertWithWhereUniqueWithoutUserInput!]
  deleteMany: [SessionScalarWhereInput!]
  updateMany: [SessionUpdateManyWithWhereNestedInput!]
}

input SessionUpdateManyWithWhereNestedInput {
  where: SessionScalarWhereInput!
  data: SessionUpdateManyDataInput!
}

input SessionUpdateWithoutUserDataInput {
  token: String
  validTo: DateTime
  timedOut: DateTime
  profile: ProfileUpdateOneInput
}

input SessionUpdateWithWhereUniqueWithoutUserInput {
  where: SessionWhereUniqueInput!
  data: SessionUpdateWithoutUserDataInput!
}

input SessionUpsertWithWhereUniqueWithoutUserInput {
  where: SessionWhereUniqueInput!
  update: SessionUpdateWithoutUserDataInput!
  create: SessionCreateWithoutUserInput!
}

input SessionWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  token: String
  token_not: String
  token_in: [String!]
  token_not_in: [String!]
  token_lt: String
  token_lte: String
  token_gt: String
  token_gte: String
  token_contains: String
  token_not_contains: String
  token_starts_with: String
  token_not_starts_with: String
  token_ends_with: String
  token_not_ends_with: String
  validTo: DateTime
  validTo_not: DateTime
  validTo_in: [DateTime!]
  validTo_not_in: [DateTime!]
  validTo_lt: DateTime
  validTo_lte: DateTime
  validTo_gt: DateTime
  validTo_gte: DateTime
  timedOut: DateTime
  timedOut_not: DateTime
  timedOut_in: [DateTime!]
  timedOut_not_in: [DateTime!]
  timedOut_lt: DateTime
  timedOut_lte: DateTime
  timedOut_gt: DateTime
  timedOut_gte: DateTime
  user: UserWhereInput
  profile: ProfileWhereInput
  AND: [SessionWhereInput!]
  OR: [SessionWhereInput!]
  NOT: [SessionWhereInput!]
}

input SessionWhereUniqueInput {
  id: ID
  token: String
}

type Subscription {
  asset(where: AssetSubscriptionWhereInput): AssetSubscriptionPayload
  attachment(where: AttachmentSubscriptionWhereInput): AttachmentSubscriptionPayload
  exchange(where: ExchangeSubscriptionWhereInput): ExchangeSubscriptionPayload
  group(where: GroupSubscriptionWhereInput): GroupSubscriptionPayload
  location(where: LocationSubscriptionWhereInput): LocationSubscriptionPayload
  membership(where: MembershipSubscriptionWhereInput): MembershipSubscriptionPayload
  message(where: MessageSubscriptionWhereInput): MessageSubscriptionPayload
  portfolio(where: PortfolioSubscriptionWhereInput): PortfolioSubscriptionPayload
  profile(where: ProfileSubscriptionWhereInput): ProfileSubscriptionPayload
  reaction(where: ReactionSubscriptionWhereInput): ReactionSubscriptionPayload
  session(where: SessionSubscriptionWhereInput): SessionSubscriptionPayload
  transaction(where: TransactionSubscriptionWhereInput): TransactionSubscriptionPayload
  user(where: UserSubscriptionWhereInput): UserSubscriptionPayload
}

type Transaction {
  id: ID!
  timestamp: DateTime!
  profile: Profile!
  asset: Asset!
  direction: TransactionDirection!
  exchange: Exchange!
  amount: Float!
}

type TransactionConnection {
  pageInfo: PageInfo!
  edges: [TransactionEdge]!
  aggregate: AggregateTransaction!
}

input TransactionCreateInput {
  id: ID
  timestamp: DateTime!
  profile: ProfileCreateOneInput!
  asset: AssetCreateOneInput!
  direction: TransactionDirection!
  exchange: ExchangeCreateOneInput!
  amount: Float!
}

input TransactionCreateManyInput {
  create: [TransactionCreateInput!]
  connect: [TransactionWhereUniqueInput!]
}

enum TransactionDirection {
  BUY
  SELL
}

type TransactionEdge {
  node: Transaction!
  cursor: String!
}

enum TransactionOrderByInput {
  id_ASC
  id_DESC
  timestamp_ASC
  timestamp_DESC
  direction_ASC
  direction_DESC
  amount_ASC
  amount_DESC
}

type TransactionPreviousValues {
  id: ID!
  timestamp: DateTime!
  direction: TransactionDirection!
  amount: Float!
}

input TransactionScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  timestamp: DateTime
  timestamp_not: DateTime
  timestamp_in: [DateTime!]
  timestamp_not_in: [DateTime!]
  timestamp_lt: DateTime
  timestamp_lte: DateTime
  timestamp_gt: DateTime
  timestamp_gte: DateTime
  direction: TransactionDirection
  direction_not: TransactionDirection
  direction_in: [TransactionDirection!]
  direction_not_in: [TransactionDirection!]
  amount: Float
  amount_not: Float
  amount_in: [Float!]
  amount_not_in: [Float!]
  amount_lt: Float
  amount_lte: Float
  amount_gt: Float
  amount_gte: Float
  AND: [TransactionScalarWhereInput!]
  OR: [TransactionScalarWhereInput!]
  NOT: [TransactionScalarWhereInput!]
}

type TransactionSubscriptionPayload {
  mutation: MutationType!
  node: Transaction
  updatedFields: [String!]
  previousValues: TransactionPreviousValues
}

input TransactionSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: TransactionWhereInput
  AND: [TransactionSubscriptionWhereInput!]
  OR: [TransactionSubscriptionWhereInput!]
  NOT: [TransactionSubscriptionWhereInput!]
}

input TransactionUpdateDataInput {
  timestamp: DateTime
  profile: ProfileUpdateOneRequiredInput
  asset: AssetUpdateOneRequiredInput
  direction: TransactionDirection
  exchange: ExchangeUpdateOneRequiredInput
  amount: Float
}

input TransactionUpdateInput {
  timestamp: DateTime
  profile: ProfileUpdateOneRequiredInput
  asset: AssetUpdateOneRequiredInput
  direction: TransactionDirection
  exchange: ExchangeUpdateOneRequiredInput
  amount: Float
}

input TransactionUpdateManyDataInput {
  timestamp: DateTime
  direction: TransactionDirection
  amount: Float
}

input TransactionUpdateManyInput {
  create: [TransactionCreateInput!]
  update: [TransactionUpdateWithWhereUniqueNestedInput!]
  upsert: [TransactionUpsertWithWhereUniqueNestedInput!]
  delete: [TransactionWhereUniqueInput!]
  connect: [TransactionWhereUniqueInput!]
  set: [TransactionWhereUniqueInput!]
  disconnect: [TransactionWhereUniqueInput!]
  deleteMany: [TransactionScalarWhereInput!]
  updateMany: [TransactionUpdateManyWithWhereNestedInput!]
}

input TransactionUpdateManyMutationInput {
  timestamp: DateTime
  direction: TransactionDirection
  amount: Float
}

input TransactionUpdateManyWithWhereNestedInput {
  where: TransactionScalarWhereInput!
  data: TransactionUpdateManyDataInput!
}

input TransactionUpdateWithWhereUniqueNestedInput {
  where: TransactionWhereUniqueInput!
  data: TransactionUpdateDataInput!
}

input TransactionUpsertWithWhereUniqueNestedInput {
  where: TransactionWhereUniqueInput!
  update: TransactionUpdateDataInput!
  create: TransactionCreateInput!
}

input TransactionWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  timestamp: DateTime
  timestamp_not: DateTime
  timestamp_in: [DateTime!]
  timestamp_not_in: [DateTime!]
  timestamp_lt: DateTime
  timestamp_lte: DateTime
  timestamp_gt: DateTime
  timestamp_gte: DateTime
  profile: ProfileWhereInput
  asset: AssetWhereInput
  direction: TransactionDirection
  direction_not: TransactionDirection
  direction_in: [TransactionDirection!]
  direction_not_in: [TransactionDirection!]
  exchange: ExchangeWhereInput
  amount: Float
  amount_not: Float
  amount_in: [Float!]
  amount_not_in: [Float!]
  amount_lt: Float
  amount_lte: Float
  amount_gt: Float
  amount_gte: Float
  AND: [TransactionWhereInput!]
  OR: [TransactionWhereInput!]
  NOT: [TransactionWhereInput!]
}

input TransactionWhereUniqueInput {
  id: ID
}

type User {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime
  name: String!
  timezone: String!
  email: String!
  password_salt: String!
  password_hash: String!
  is_verified: Boolean!
  challenge: String
  profiles(where: ProfileWhereInput, orderBy: ProfileOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Profile!]
  sessions(where: SessionWhereInput, orderBy: SessionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Session!]
  lastUsedProfileId: String
}

type UserConnection {
  pageInfo: PageInfo!
  edges: [UserEdge]!
  aggregate: AggregateUser!
}

input UserCreateInput {
  id: ID
  name: String!
  timezone: String!
  email: String!
  password_salt: String!
  password_hash: String!
  is_verified: Boolean!
  challenge: String
  profiles: ProfileCreateManyInput
  sessions: SessionCreateManyWithoutUserInput
  lastUsedProfileId: String
}

input UserCreateOneWithoutSessionsInput {
  create: UserCreateWithoutSessionsInput
  connect: UserWhereUniqueInput
}

input UserCreateWithoutSessionsInput {
  id: ID
  name: String!
  timezone: String!
  email: String!
  password_salt: String!
  password_hash: String!
  is_verified: Boolean!
  challenge: String
  profiles: ProfileCreateManyInput
  lastUsedProfileId: String
}

type UserEdge {
  node: User!
  cursor: String!
}

enum UserOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  name_ASC
  name_DESC
  timezone_ASC
  timezone_DESC
  email_ASC
  email_DESC
  password_salt_ASC
  password_salt_DESC
  password_hash_ASC
  password_hash_DESC
  is_verified_ASC
  is_verified_DESC
  challenge_ASC
  challenge_DESC
  lastUsedProfileId_ASC
  lastUsedProfileId_DESC
}

type UserPreviousValues {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime
  name: String!
  timezone: String!
  email: String!
  password_salt: String!
  password_hash: String!
  is_verified: Boolean!
  challenge: String
  lastUsedProfileId: String
}

type UserSubscriptionPayload {
  mutation: MutationType!
  node: User
  updatedFields: [String!]
  previousValues: UserPreviousValues
}

input UserSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UserWhereInput
  AND: [UserSubscriptionWhereInput!]
  OR: [UserSubscriptionWhereInput!]
  NOT: [UserSubscriptionWhereInput!]
}

input UserUpdateInput {
  name: String
  timezone: String
  email: String
  password_salt: String
  password_hash: String
  is_verified: Boolean
  challenge: String
  profiles: ProfileUpdateManyInput
  sessions: SessionUpdateManyWithoutUserInput
  lastUsedProfileId: String
}

input UserUpdateManyMutationInput {
  name: String
  timezone: String
  email: String
  password_salt: String
  password_hash: String
  is_verified: Boolean
  challenge: String
  lastUsedProfileId: String
}

input UserUpdateOneRequiredWithoutSessionsInput {
  create: UserCreateWithoutSessionsInput
  update: UserUpdateWithoutSessionsDataInput
  upsert: UserUpsertWithoutSessionsInput
  connect: UserWhereUniqueInput
}

input UserUpdateWithoutSessionsDataInput {
  name: String
  timezone: String
  email: String
  password_salt: String
  password_hash: String
  is_verified: Boolean
  challenge: String
  profiles: ProfileUpdateManyInput
  lastUsedProfileId: String
}

input UserUpsertWithoutSessionsInput {
  update: UserUpdateWithoutSessionsDataInput!
  create: UserCreateWithoutSessionsInput!
}

input UserWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  timezone: String
  timezone_not: String
  timezone_in: [String!]
  timezone_not_in: [String!]
  timezone_lt: String
  timezone_lte: String
  timezone_gt: String
  timezone_gte: String
  timezone_contains: String
  timezone_not_contains: String
  timezone_starts_with: String
  timezone_not_starts_with: String
  timezone_ends_with: String
  timezone_not_ends_with: String
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  password_salt: String
  password_salt_not: String
  password_salt_in: [String!]
  password_salt_not_in: [String!]
  password_salt_lt: String
  password_salt_lte: String
  password_salt_gt: String
  password_salt_gte: String
  password_salt_contains: String
  password_salt_not_contains: String
  password_salt_starts_with: String
  password_salt_not_starts_with: String
  password_salt_ends_with: String
  password_salt_not_ends_with: String
  password_hash: String
  password_hash_not: String
  password_hash_in: [String!]
  password_hash_not_in: [String!]
  password_hash_lt: String
  password_hash_lte: String
  password_hash_gt: String
  password_hash_gte: String
  password_hash_contains: String
  password_hash_not_contains: String
  password_hash_starts_with: String
  password_hash_not_starts_with: String
  password_hash_ends_with: String
  password_hash_not_ends_with: String
  is_verified: Boolean
  is_verified_not: Boolean
  challenge: String
  challenge_not: String
  challenge_in: [String!]
  challenge_not_in: [String!]
  challenge_lt: String
  challenge_lte: String
  challenge_gt: String
  challenge_gte: String
  challenge_contains: String
  challenge_not_contains: String
  challenge_starts_with: String
  challenge_not_starts_with: String
  challenge_ends_with: String
  challenge_not_ends_with: String
  profiles_every: ProfileWhereInput
  profiles_some: ProfileWhereInput
  profiles_none: ProfileWhereInput
  sessions_every: SessionWhereInput
  sessions_some: SessionWhereInput
  sessions_none: SessionWhereInput
  lastUsedProfileId: String
  lastUsedProfileId_not: String
  lastUsedProfileId_in: [String!]
  lastUsedProfileId_not_in: [String!]
  lastUsedProfileId_lt: String
  lastUsedProfileId_lte: String
  lastUsedProfileId_gt: String
  lastUsedProfileId_gte: String
  lastUsedProfileId_contains: String
  lastUsedProfileId_not_contains: String
  lastUsedProfileId_starts_with: String
  lastUsedProfileId_not_starts_with: String
  lastUsedProfileId_ends_with: String
  lastUsedProfileId_not_ends_with: String
  AND: [UserWhereInput!]
  OR: [UserWhereInput!]
  NOT: [UserWhereInput!]
}

input UserWhereUniqueInput {
  id: ID
  email: String
}
`